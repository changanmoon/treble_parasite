From 6a03c0a8b26a326cc0531a1cbbddbc2129080ea6 Mon Sep 17 00:00:00 2001
From: Scott Warner <Tortel1210@gmail.com>
Date: Tue, 9 Apr 2024 16:26:35 -0400
Subject: [PATCH] DNM: Mass revert of BT breaking changes

QPR2 causes all sorts of issues with Bluetooth - I don't have time to figure out
a proper fix, so for now just revert all this shit.

commit 6af2075e23d90bcdc1e701292826d03a26c8162d
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:06:41 2024 -0400

    Revert "[Invisalign2] Separate security fields from tBTM_SEC_DEV_REC"

    This reverts commit 2c92bb2653a77eded8bfdf25914f23b51a377309.

commit 71b4aee8cbc4842c07f8f442c8f9c9d15d40e7d9
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:06:28 2024 -0400

    Revert "[Invisalign2] move btm_ble_increment_sign_ctr to tBTM_SEC_REC"

    This reverts commit d337520d761b1b4cd10d55294782fbf4849928e6.

commit f823396d71391de6512049d8ef760a6d5ef4adc3
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:06:13 2024 -0400

    Revert "[Invisalign2] make enc_handle public and remove friends"

    This reverts commit 77aae31a84695be346ae24c1bbdc9faabfe6145d.

commit 5782c36d320758e53ea4e97ee50e8936d0db6612
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:05:57 2024 -0400

    Revert "[Invisalign2] Encapsulate the following methods"

    This reverts commit 5e2b41b9f26319c3da87788d6a08a945562d0efe.

commit 85b531a9fa71c172eaf90a2d97d61d3f4c13146c
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:05:36 2024 -0400

    Revert "[Invisalign2] Encapsulate tBTM_SEC_CB::AddService"

    This reverts commit 94396cb21a99010a0a368e03fe513343e6f1070c.

commit 3cbe09603d00cdf351d0652f8e2da54e432cbdde
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:05:19 2024 -0400

    Revert "[Invisalign2] Encapsulate tBTM_SEC_CB::RemoveServiceById"

    This reverts commit e06e22debc40ec2e2c8cf725c8c9dff8cd65e535.

commit e954a81edbdb2767d000332d86df8fa7f231ea57
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:04:57 2024 -0400

    Revert "[Invisalign2] Encapsulate tBTM_SEC_CB::RemoveServiceByPsm"

    This reverts commit f9b68125655d1c7ca67075a59f70adcf304e694f.

commit bfd2e764a0e9a90073bd6efa905976d10ebf5075
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:04:42 2024 -0400

    Revert "[Invisalign2] Encapsulate tBTM_SEC_CB::IsDeviceBonded"

    This reverts commit ed2401a9d1e6f181c0068df2e11c41362392b671.

commit 6007362a73e11249e5529de71b254f98170db2df
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:04:24 2024 -0400

    Revert "[Invisalign2] Enacapsulate btm_pair_state_descr"

    This reverts commit 6eb676f49398917e347a48e6a4b7e3d2b92d39d4.

commit 2da0abe296752540d0e7d9b2959d07e36c28f8d3
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:04:01 2024 -0400

    Revert "[Invisalign2] Encapsulate tBTM_SEC_CB::change_pairing_state"

    This reverts commit 60ed51daac51fa6fe7e5d7fb796957171637ad1f.

commit c6bc163ce3efb448a38954adec8a0957201a5871
Author: Scott Warner <Tortel1210@gmail.com>
Date:   Tue Apr 9 11:03:42 2024 -0400

    Revert "Copy the keys when re-pairing with a new RPA/IRK"

    This reverts commit f475f3c1bc301c30ab10f013e30f61bdd74eb452.

Change-Id: Idcd03a9f092cc16e71d6e778c75e2b2a02a3e92f
---
 system/bta/test/common/btm_api_mock.cc      |    8 +
 system/stack/btm/btm_ble_addr.cc            |    8 +-
 system/stack/btm/btm_ble_privacy.cc         |    6 +-
 system/stack/btm/btm_ble_sec.cc             |  243 +++--
 system/stack/btm/btm_dev.cc                 |   57 +-
 system/stack/btm/btm_devctl.cc              |    2 +-
 system/stack/btm/btm_sec.cc                 | 1031 +++++++++++--------
 system/stack/btm/btm_sec.h                  |   13 +
 system/stack/btm/btm_sec_cb.cc              |  250 +----
 system/stack/btm/btm_sec_cb.h               |   35 +-
 system/stack/btm/security_device_record.h   |  111 +-
 system/stack/gatt/gatt_api.cc               |    4 +-
 system/stack/smp/smp_act.cc                 |    8 +-
 system/stack/smp/smp_keys.cc                |    4 +-
 system/stack/smp/smp_l2c.cc                 |    2 +-
 system/stack/test/btm/stack_btm_sec_test.cc |   18 +-
 system/stack/test/gatt/gatt_api_test.cc     |    7 +-
 system/test/mock/mock_stack_btm_sec.cc      |    9 +
 system/test/mock/mock_stack_btm_sec.h       |   16 +
 19 files changed, 887 insertions(+), 945 deletions(-)

diff --git a/system/bta/test/common/btm_api_mock.cc b/system/bta/test/common/btm_api_mock.cc
index 05599ab5a2..1682ff9ae4 100644
--- a/system/bta/test/common/btm_api_mock.cc
+++ b/system/bta/test/common/btm_api_mock.cc
@@ -30,6 +30,14 @@ void bluetooth::manager::SetMockBtmInterface(
   btm_interface = mock_btm_interface;
 }
 
+bool BTM_GetSecurityFlagsByTransport(const RawAddress& bd_addr,
+                                     uint8_t* p_sec_flags,
+                                     tBT_TRANSPORT transport) {
+  LOG_ASSERT(btm_interface) << "Mock btm interface not set!";
+  return btm_interface->GetSecurityFlagsByTransport(bd_addr, p_sec_flags,
+                                                    transport);
+}
+
 bool BTM_IsLinkKeyKnown(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
   LOG_ASSERT(btm_interface) << "Mock btm interface not set!";
   return btm_interface->IsLinkKeyKnown(bd_addr, transport);
diff --git a/system/stack/btm/btm_ble_addr.cc b/system/stack/btm/btm_ble_addr.cc
index 8234ecdfc6..f03567466e 100644
--- a/system/stack/btm/btm_ble_addr.cc
+++ b/system/stack/btm/btm_ble_addr.cc
@@ -147,8 +147,8 @@ bool btm_ble_addr_resolvable(const RawAddress& rpa,
   if (!BTM_BLE_IS_RESOLVE_BDA(rpa)) return false;
 
   if ((p_dev_rec->device_type & BT_DEVICE_TYPE_BLE) &&
-      (p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PID)) {
-    if (rpa_matches_irk(rpa, p_dev_rec->sec_rec.ble_keys.irk)) {
+      (p_dev_rec->ble_keys.key_type & BTM_LE_KEY_PID)) {
+    if (rpa_matches_irk(rpa, p_dev_rec->ble_keys.irk)) {
       btm_ble_init_pseudo_addr(p_dev_rec, rpa);
       return true;
     }
@@ -164,11 +164,11 @@ static bool btm_ble_match_random_bda(void* data, void* context) {
   RawAddress* random_bda = static_cast<RawAddress*>(context);
 
   if (!(p_dev_rec->device_type & BT_DEVICE_TYPE_BLE) ||
-      !(p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PID))
+      !(p_dev_rec->ble_keys.key_type & BTM_LE_KEY_PID))
     // Match fails preconditions
     return true;
 
-  if (rpa_matches_irk(*random_bda, p_dev_rec->sec_rec.ble_keys.irk)) {
+  if (rpa_matches_irk(*random_bda, p_dev_rec->ble_keys.irk)) {
     // Matched
     return false;
   }
diff --git a/system/stack/btm/btm_ble_privacy.cc b/system/stack/btm/btm_ble_privacy.cc
index 4c527c8e74..c46af0b9f5 100644
--- a/system/stack/btm/btm_ble_privacy.cc
+++ b/system/stack/btm/btm_ble_privacy.cc
@@ -532,7 +532,7 @@ static void btm_ble_ble_unsupported_resolving_list_load_dev(
   uint8_t* p = param;
 
   UINT8_TO_STREAM(p, BTM_BLE_META_ADD_IRK_ENTRY);
-  ARRAY_TO_STREAM(p, p_dev_rec->sec_rec.ble_keys.irk, OCTET16_LEN);
+  ARRAY_TO_STREAM(p, p_dev_rec->ble_keys.irk, OCTET16_LEN);
   UINT8_TO_STREAM(p, p_dev_rec->ble.identity_address_with_type.type);
   BDADDR_TO_STREAM(p, p_dev_rec->ble.identity_address_with_type.bda);
 
@@ -545,7 +545,7 @@ static void btm_ble_ble_unsupported_resolving_list_load_dev(
 }
 
 static bool is_peer_identity_key_valid(const tBTM_SEC_DEV_REC& dev_rec) {
-  return dev_rec.sec_rec.ble_keys.key_type & BTM_LE_KEY_PID;
+  return dev_rec.ble_keys.key_type & BTM_LE_KEY_PID;
 }
 
 static Octet16 get_local_irk() { return btm_sec_cb.devcb.id_keys.irk; }
@@ -577,7 +577,7 @@ void btm_ble_resolving_list_load_dev(tBTM_SEC_DEV_REC& dev_rec) {
     return;
   }
 
-  const Octet16& peer_irk = dev_rec.sec_rec.ble_keys.irk;
+  const Octet16& peer_irk = dev_rec.ble_keys.irk;
   const Octet16& local_irk = get_local_irk();
 
   if (dev_rec.ble.identity_address_with_type.bda.IsEmpty()) {
diff --git a/system/stack/btm/btm_ble_sec.cc b/system/stack/btm/btm_ble_sec.cc
index 6d4c06f696..0417736b1e 100644
--- a/system/stack/btm/btm_ble_sec.cc
+++ b/system/stack/btm/btm_ble_sec.cc
@@ -284,7 +284,7 @@ void BTM_BlePasskeyReply(const RawAddress& bd_addr, uint8_t res,
                                     bt_transport_text(BT_TRANSPORT_LE).c_str(),
                                     smp_status_text(res_smp).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
   SMP_PasskeyReply(bd_addr, res_smp, passkey);
 }
 
@@ -316,7 +316,7 @@ void BTM_BleConfirmReply(const RawAddress& bd_addr, uint8_t res) {
                      bt_transport_text(BT_TRANSPORT_LE).c_str(),
                      smp_status_text(res_smp).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
   SMP_ConfirmReply(bd_addr, res_smp);
 }
 
@@ -349,7 +349,7 @@ void BTM_BleOobDataReply(const RawAddress& bd_addr, uint8_t res, uint8_t len,
                                     bt_transport_text(BT_TRANSPORT_LE).c_str(),
                                     smp_status_text(res_smp).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
   SMP_OobDataReply(bd_addr, res_smp, len, p_data);
 }
 
@@ -379,7 +379,7 @@ void BTM_BleSecureConnectionOobDataReply(const RawAddress& bd_addr,
       base::StringPrintf("transport:%s",
                          bt_transport_text(BT_TRANSPORT_LE).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
 
   tSMP_SC_OOB_DATA oob;
   memset(&oob, 0, sizeof(tSMP_SC_OOB_DATA));
@@ -792,21 +792,28 @@ tBTM_STATUS btm_ble_start_sec_check(const RawAddress& bd_addr, uint16_t psm,
 
 /*******************************************************************************
  *
- * Function         increment_sign_counter
+ * Function         btm_ble_get_enc_key_type
  *
- * Description      This method is to increment the (local or peer) sign counter
+ * Description      This function is to increment local sign counter
  * Returns         None
  *
  ******************************************************************************/
-void tBTM_SEC_REC::increment_sign_counter(bool local) {
-  if (local) {
-    ble_keys.local_counter++;
-  } else {
-    ble_keys.counter++;
-  }
+static void btm_ble_increment_sign_ctr(const RawAddress& bd_addr,
+                                       bool is_local) {
+  tBTM_SEC_DEV_REC* p_dev_rec;
+
+  LOG_VERBOSE("btm_ble_increment_sign_ctr is_local=%d", is_local);
 
-  LOG_VERBOSE("local=%d local sign counter=%d peer sign counter=%d", local,
-              ble_keys.local_counter, ble_keys.counter);
+  p_dev_rec = btm_find_dev(bd_addr);
+  if (p_dev_rec != NULL) {
+    if (is_local)
+      p_dev_rec->ble_keys.local_counter++;
+    else
+      p_dev_rec->ble_keys.counter++;
+    LOG_VERBOSE("is_local=%d local sign counter=%d peer sign counter=%d",
+                is_local, p_dev_rec->ble_keys.local_counter,
+                p_dev_rec->ble_keys.counter);
+  }
 }
 
 /*******************************************************************************
@@ -826,7 +833,7 @@ bool btm_ble_get_enc_key_type(const RawAddress& bd_addr, uint8_t* p_key_types) {
 
   p_dev_rec = btm_find_dev(bd_addr);
   if (p_dev_rec != NULL) {
-    *p_key_types = p_dev_rec->sec_rec.ble_keys.key_type;
+    *p_key_types = p_dev_rec->ble_keys.key_type;
     return true;
   }
   return false;
@@ -847,9 +854,9 @@ bool btm_get_local_div(const RawAddress& bd_addr, uint16_t* p_div) {
   *p_div = 0;
   p_dev_rec = btm_find_dev(bd_addr);
 
-  if (p_dev_rec && p_dev_rec->sec_rec.ble_keys.div) {
+  if (p_dev_rec && p_dev_rec->ble_keys.div) {
     status = true;
-    *p_div = p_dev_rec->sec_rec.ble_keys.div;
+    *p_div = p_dev_rec->ble_keys.div;
   }
   LOG_VERBOSE("status=%d (1-OK) DIV=0x%x", status, *p_div);
   return status;
@@ -884,36 +891,34 @@ void btm_sec_save_le_key(const RawAddress& bd_addr, tBTM_LE_KEY_TYPE key_type,
 
     switch (key_type) {
       case BTM_LE_KEY_PENC:
-        p_rec->sec_rec.ble_keys.pltk = p_keys->penc_key.ltk;
-        memcpy(p_rec->sec_rec.ble_keys.rand, p_keys->penc_key.rand,
-               BT_OCTET8_LEN);
-        p_rec->sec_rec.ble_keys.sec_level = p_keys->penc_key.sec_level;
-        p_rec->sec_rec.ble_keys.ediv = p_keys->penc_key.ediv;
-        p_rec->sec_rec.ble_keys.key_size = p_keys->penc_key.key_size;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_PENC;
-        p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
+        p_rec->ble_keys.pltk = p_keys->penc_key.ltk;
+        memcpy(p_rec->ble_keys.rand, p_keys->penc_key.rand, BT_OCTET8_LEN);
+        p_rec->ble_keys.sec_level = p_keys->penc_key.sec_level;
+        p_rec->ble_keys.ediv = p_keys->penc_key.ediv;
+        p_rec->ble_keys.key_size = p_keys->penc_key.key_size;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_PENC;
+        p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
         if (p_keys->penc_key.sec_level == SMP_SEC_AUTHENTICATED)
-          p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
         else
-          p_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
         LOG_VERBOSE(
             "BTM_LE_KEY_PENC key_type=0x%x sec_flags=0x%x sec_leve=0x%x",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.sec_flags,
-            p_rec->sec_rec.ble_keys.sec_level);
+            p_rec->ble_keys.key_type, p_rec->sec_flags,
+            p_rec->ble_keys.sec_level);
         break;
 
       case BTM_LE_KEY_PID:
-        p_rec->sec_rec.ble_keys.irk = p_keys->pid_key.irk;
+        p_rec->ble_keys.irk = p_keys->pid_key.irk;
         p_rec->ble.identity_address_with_type.bda =
             p_keys->pid_key.identity_addr;
         p_rec->ble.identity_address_with_type.type =
             p_keys->pid_key.identity_addr_type;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_PID;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_PID;
         LOG_VERBOSE(
             "BTM_LE_KEY_PID key_type=0x%x save peer IRK, change bd_addr=%s "
             "to id_addr=%s id_addr_type=0x%x",
-            p_rec->sec_rec.ble_keys.key_type,
-            ADDRESS_TO_LOGGABLE_CSTR(p_rec->bd_addr),
+            p_rec->ble_keys.key_type, ADDRESS_TO_LOGGABLE_CSTR(p_rec->bd_addr),
             ADDRESS_TO_LOGGABLE_CSTR(p_keys->pid_key.identity_addr),
             p_keys->pid_key.identity_addr_type);
         /* update device record address as identity address */
@@ -923,56 +928,53 @@ void btm_sec_save_le_key(const RawAddress& bd_addr, tBTM_LE_KEY_TYPE key_type,
         break;
 
       case BTM_LE_KEY_PCSRK:
-        p_rec->sec_rec.ble_keys.pcsrk = p_keys->pcsrk_key.csrk;
-        p_rec->sec_rec.ble_keys.srk_sec_level = p_keys->pcsrk_key.sec_level;
-        p_rec->sec_rec.ble_keys.counter = p_keys->pcsrk_key.counter;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_PCSRK;
-        p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
+        p_rec->ble_keys.pcsrk = p_keys->pcsrk_key.csrk;
+        p_rec->ble_keys.srk_sec_level = p_keys->pcsrk_key.sec_level;
+        p_rec->ble_keys.counter = p_keys->pcsrk_key.counter;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_PCSRK;
+        p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
         if (p_keys->pcsrk_key.sec_level == SMP_SEC_AUTHENTICATED)
-          p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
         else
-          p_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
 
         LOG_VERBOSE(
             "BTM_LE_KEY_PCSRK key_type=0x%x sec_flags=0x%x sec_level=0x%x "
             "peer_counter=%d",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.sec_flags,
-            p_rec->sec_rec.ble_keys.srk_sec_level,
-            p_rec->sec_rec.ble_keys.counter);
+            p_rec->ble_keys.key_type, p_rec->sec_flags,
+            p_rec->ble_keys.srk_sec_level, p_rec->ble_keys.counter);
         break;
 
       case BTM_LE_KEY_LENC:
-        p_rec->sec_rec.ble_keys.lltk = p_keys->lenc_key.ltk;
-        p_rec->sec_rec.ble_keys.div = p_keys->lenc_key.div; /* update DIV */
-        p_rec->sec_rec.ble_keys.sec_level = p_keys->lenc_key.sec_level;
-        p_rec->sec_rec.ble_keys.key_size = p_keys->lenc_key.key_size;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_LENC;
+        p_rec->ble_keys.lltk = p_keys->lenc_key.ltk;
+        p_rec->ble_keys.div = p_keys->lenc_key.div; /* update DIV */
+        p_rec->ble_keys.sec_level = p_keys->lenc_key.sec_level;
+        p_rec->ble_keys.key_size = p_keys->lenc_key.key_size;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_LENC;
 
         LOG_VERBOSE(
             "BTM_LE_KEY_LENC key_type=0x%x DIV=0x%x key_size=0x%x "
             "sec_level=0x%x",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.ble_keys.div,
-            p_rec->sec_rec.ble_keys.key_size,
-            p_rec->sec_rec.ble_keys.sec_level);
+            p_rec->ble_keys.key_type, p_rec->ble_keys.div,
+            p_rec->ble_keys.key_size, p_rec->ble_keys.sec_level);
         break;
 
       case BTM_LE_KEY_LCSRK: /* local CSRK has been delivered */
-        p_rec->sec_rec.ble_keys.lcsrk = p_keys->lcsrk_key.csrk;
-        p_rec->sec_rec.ble_keys.div = p_keys->lcsrk_key.div; /* update DIV */
-        p_rec->sec_rec.ble_keys.local_csrk_sec_level =
-            p_keys->lcsrk_key.sec_level;
-        p_rec->sec_rec.ble_keys.local_counter = p_keys->lcsrk_key.counter;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_LCSRK;
+        p_rec->ble_keys.lcsrk = p_keys->lcsrk_key.csrk;
+        p_rec->ble_keys.div = p_keys->lcsrk_key.div; /* update DIV */
+        p_rec->ble_keys.local_csrk_sec_level = p_keys->lcsrk_key.sec_level;
+        p_rec->ble_keys.local_counter = p_keys->lcsrk_key.counter;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_LCSRK;
         LOG_VERBOSE(
             "BTM_LE_KEY_LCSRK key_type=0x%x DIV=0x%x scrk_sec_level=0x%x "
             "local_counter=%d",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.ble_keys.div,
-            p_rec->sec_rec.ble_keys.local_csrk_sec_level,
-            p_rec->sec_rec.ble_keys.local_counter);
+            p_rec->ble_keys.key_type, p_rec->ble_keys.div,
+            p_rec->ble_keys.local_csrk_sec_level,
+            p_rec->ble_keys.local_counter);
         break;
 
       case BTM_LE_KEY_LID:
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_LID;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_LID;
         break;
       default:
         LOG_WARN("btm_sec_save_le_key (Bad key_type 0x%02x)", key_type);
@@ -997,7 +999,7 @@ void btm_sec_save_le_key(const RawAddress& bd_addr, tBTM_LE_KEY_TYPE key_type,
            ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
 
   if (p_rec) {
-    LOG_VERBOSE("sec_flags=0x%x", p_rec->sec_rec.sec_flags);
+    LOG_VERBOSE("sec_flags=0x%x", p_rec->sec_flags);
   }
 }
 
@@ -1019,7 +1021,7 @@ void btm_ble_update_sec_key_size(const RawAddress& bd_addr,
 
   p_rec = btm_find_dev(bd_addr);
   if (p_rec != NULL) {
-    p_rec->sec_rec.enc_key_size = enc_key_size;
+    p_rec->enc_key_size = enc_key_size;
   }
 }
 
@@ -1037,7 +1039,7 @@ uint8_t btm_ble_read_sec_key_size(const RawAddress& bd_addr) {
 
   p_rec = btm_find_dev(bd_addr);
   if (p_rec != NULL) {
-    return p_rec->sec_rec.enc_key_size;
+    return p_rec->enc_key_size;
   } else
     return 0;
 }
@@ -1065,8 +1067,8 @@ void btm_ble_link_sec_check(const RawAddress& bd_addr,
     return;
   }
 
-  if (p_dev_rec->sec_rec.is_security_state_encrypting() ||
-      p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+  if (p_dev_rec->is_security_state_encrypting() ||
+      p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
     /* race condition: discard the security request while central is encrypting
      * the link */
     *p_sec_req_act = BTM_BLE_SEC_REQ_ACT_DISCARD;
@@ -1076,19 +1078,19 @@ void btm_ble_link_sec_check(const RawAddress& bd_addr,
       req_sec_level = SMP_SEC_AUTHENTICATED;
     }
 
-    LOG_VERBOSE("dev_rec sec_flags=0x%x", p_dev_rec->sec_rec.sec_flags);
+    LOG_VERBOSE("dev_rec sec_flags=0x%x", p_dev_rec->sec_flags);
 
     /* currently encrpted  */
-    if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_ENCRYPTED) {
-      if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_AUTHENTICATED)
+    if (p_dev_rec->sec_flags & BTM_SEC_LE_ENCRYPTED) {
+      if (p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED)
         cur_sec_level = SMP_SEC_AUTHENTICATED;
       else
         cur_sec_level = SMP_SEC_UNAUTHENTICATE;
     } else /* unencrypted link */
     {
       /* if bonded, get the key security level */
-      if (p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PENC)
-        cur_sec_level = p_dev_rec->sec_rec.ble_keys.sec_level;
+      if (p_dev_rec->ble_keys.key_type & BTM_LE_KEY_PENC)
+        cur_sec_level = p_dev_rec->ble_keys.sec_level;
       else
         cur_sec_level = SMP_SEC_NONE;
     }
@@ -1136,7 +1138,7 @@ tBTM_STATUS btm_ble_set_encryption(const RawAddress& bd_addr,
   LOG_VERBOSE("sec_act=0x%x role_central=%d", sec_act, p_rec->role_central);
 
   if (sec_act == BTM_BLE_SEC_ENCRYPT_MITM) {
-    p_rec->sec_rec.security_required |= BTM_SEC_IN_MITM;
+    p_rec->security_required |= BTM_SEC_IN_MITM;
   }
 
   switch (sec_act) {
@@ -1170,7 +1172,7 @@ tBTM_STATUS btm_ble_set_encryption(const RawAddress& bd_addr,
 
       if (SMP_Pair(bd_addr) == SMP_STARTED) {
         cmd = BTM_CMD_STARTED;
-        p_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+        p_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
       }
       break;
 
@@ -1225,7 +1227,7 @@ tBTM_STATUS btm_ble_start_encrypt(const RawAddress& bda, bool use_stk,
     return BTM_WRONG_MODE;
   }
 
-  if (p_rec->sec_rec.is_security_state_encrypting()) {
+  if (p_rec->is_security_state_encrypting()) {
     LOG_WARN("Link Encryption is active, Busy!");
     return BTM_BUSY;
   }
@@ -1234,17 +1236,16 @@ tBTM_STATUS btm_ble_start_encrypt(const RawAddress& bda, bool use_stk,
 
   if (use_stk) {
     btsnd_hcic_ble_start_enc(p_rec->ble_hci_handle, dummy_rand, 0, *p_stk);
-  } else if (p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PENC) {
-    btsnd_hcic_ble_start_enc(
-        p_rec->ble_hci_handle, p_rec->sec_rec.ble_keys.rand,
-        p_rec->sec_rec.ble_keys.ediv, p_rec->sec_rec.ble_keys.pltk);
+  } else if (p_rec->ble_keys.key_type & BTM_LE_KEY_PENC) {
+    btsnd_hcic_ble_start_enc(p_rec->ble_hci_handle, p_rec->ble_keys.rand,
+                             p_rec->ble_keys.ediv, p_rec->ble_keys.pltk);
   } else {
     LOG_ERROR("No key available to encrypt the link");
     return BTM_ERR_KEY_MISSING;
   }
 
-  if (p_rec->sec_rec.sec_state == BTM_SEC_STATE_IDLE)
-    p_rec->sec_rec.sec_state = BTM_SEC_STATE_LE_ENCRYPTING;
+  if (p_rec->sec_state == BTM_SEC_STATE_IDLE)
+    p_rec->sec_state = BTM_SEC_STATE_LE_ENCRYPTING;
 
   return BTM_CMD_STARTED;
 }
@@ -1305,24 +1306,23 @@ void btm_ble_link_encrypted(const RawAddress& bd_addr, uint8_t encr_enable) {
     return;
   }
 
-  enc_cback = p_dev_rec->sec_rec.is_security_state_le_encrypting();
+  enc_cback = p_dev_rec->is_security_state_le_encrypting();
 
   smp_link_encrypted(bd_addr, encr_enable);
 
-  LOG_VERBOSE("p_dev_rec->sec_rec.sec_flags=0x%x",
-              p_dev_rec->sec_rec.sec_flags);
+  LOG_VERBOSE("p_dev_rec->sec_flags=0x%x", p_dev_rec->sec_flags);
 
-  if (encr_enable && p_dev_rec->sec_rec.enc_key_size == 0)
-    p_dev_rec->sec_rec.enc_key_size = p_dev_rec->sec_rec.ble_keys.key_size;
+  if (encr_enable && p_dev_rec->enc_key_size == 0)
+    p_dev_rec->enc_key_size = p_dev_rec->ble_keys.key_size;
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
-  if (p_dev_rec->sec_rec.p_callback && enc_cback) {
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
+  if (p_dev_rec->p_callback && enc_cback) {
     if (encr_enable) btm_sec_dev_rec_cback_event(p_dev_rec, BTM_SUCCESS, true);
     /* LTK missing on peripheral */
     else if (p_dev_rec->role_central &&
-             (p_dev_rec->sec_rec.sec_status == HCI_ERR_KEY_MISSING)) {
+             (p_dev_rec->sec_status == HCI_ERR_KEY_MISSING)) {
       btm_sec_dev_rec_cback_event(p_dev_rec, BTM_ERR_KEY_MISSING, true);
-    } else if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN)) {
+    } else if (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN)) {
       btm_sec_dev_rec_cback_event(p_dev_rec, BTM_FAILED_ON_SECURITY, true);
     } else if (p_dev_rec->role_central)
       btm_sec_dev_rec_cback_event(p_dev_rec, BTM_ERR_PROCESSING, true);
@@ -1368,17 +1368,16 @@ void btm_ble_ltk_request_reply(const RawAddress& bda, bool use_stk,
   }
 
   p_cb->enc_handle = p_rec->ble_hci_handle;
-  p_cb->key_size = p_rec->sec_rec.ble_keys.key_size;
+  p_cb->key_size = p_rec->ble_keys.key_size;
 
-  LOG_ERROR("key size=%d", p_rec->sec_rec.ble_keys.key_size);
+  LOG_ERROR("key size=%d", p_rec->ble_keys.key_size);
   if (use_stk) {
     btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle, stk);
     return;
   }
   /* calculate LTK using peer device  */
-  if (p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_LENC) {
-    btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle,
-                                 p_rec->sec_rec.ble_keys.lltk);
+  if (p_rec->ble_keys.key_type & BTM_LE_KEY_LENC) {
+    btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle, p_rec->ble_keys.lltk);
     return;
   }
 
@@ -1395,10 +1394,9 @@ void btm_ble_ltk_request_reply(const RawAddress& bda, bool use_stk,
    * end up here. We will eventually consolidate both entries, this is to avoid
    * race conditions. */
 
-  LOG_ASSERT(p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_LENC);
-  p_cb->key_size = p_rec->sec_rec.ble_keys.key_size;
-  btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle,
-                               p_rec->sec_rec.ble_keys.lltk);
+  LOG_ASSERT(p_rec->ble_keys.key_type & BTM_LE_KEY_LENC);
+  p_cb->key_size = p_rec->ble_keys.key_size;
+  btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle, p_rec->ble_keys.lltk);
 }
 
 /*******************************************************************************
@@ -1424,13 +1422,13 @@ static uint8_t btm_ble_io_capabilities_req(tBTM_SEC_DEV_REC* p_dev_rec,
   if ((callback_rc == BTM_SUCCESS) || (BTM_OOB_UNKNOWN != p_data->oob_data)) {
     p_data->auth_req &= BTM_LE_AUTH_REQ_MASK;
 
-    LOG_VERBOSE("1:p_dev_rec->sec_rec.security_required=%d, auth_req:%d",
-                p_dev_rec->sec_rec.security_required, p_data->auth_req);
+    LOG_VERBOSE("1:p_dev_rec->security_required=%d, auth_req:%d",
+                p_dev_rec->security_required, p_data->auth_req);
     LOG_VERBOSE("2:i_keys=0x%x r_keys=0x%x (bit 0-LTK 1-IRK 2-CSRK)",
                 p_data->init_keys, p_data->resp_keys);
 
     /* if authentication requires MITM protection, put on the mask */
-    if (p_dev_rec->sec_rec.security_required & BTM_SEC_IN_MITM)
+    if (p_dev_rec->security_required & BTM_SEC_IN_MITM)
       p_data->auth_req |= BTM_LE_AUTH_REQ_MITM;
 
     if (!(p_data->auth_req & SMP_AUTH_BOND)) {
@@ -1576,7 +1574,7 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
       case SMP_OOB_REQ_EVT:
       case SMP_NC_REQ_EVT:
       case SMP_SC_OOB_REQ_EVT:
-        p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+        p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
         FALLTHROUGH_INTENDED; /* FALLTHROUGH */
 
       case SMP_CONSENT_REQ_EVT:
@@ -1588,7 +1586,7 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
         }
         btm_sec_cb.pairing_bda = bd_addr;
         if (event != SMP_CONSENT_REQ_EVT) {
-          p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+          p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
         }
         btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_LE_ACTIVE;
         FALLTHROUGH_INTENDED; /* FALLTHROUGH */
@@ -1610,14 +1608,13 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
             return BTM_SUCCESS;
           }
           LOG_VERBOSE("before update sec_level=0x%x sec_flags=0x%x",
-                      p_data->cmplt.sec_level, p_dev_rec->sec_rec.sec_flags);
+                      p_data->cmplt.sec_level, p_dev_rec->sec_flags);
 
           res = (p_data->cmplt.reason == SMP_SUCCESS) ? BTM_SUCCESS
                                                       : BTM_ERR_PROCESSING;
 
           LOG_VERBOSE("after update result=%d sec_level=0x%x sec_flags=0x%x",
-                      res, p_data->cmplt.sec_level,
-                      p_dev_rec->sec_rec.sec_flags);
+                      res, p_data->cmplt.sec_level, p_dev_rec->sec_flags);
 
           if (p_data->cmplt.is_pair_cancel &&
               btm_sec_cb.api.p_bond_cancel_cmpl_callback) {
@@ -1644,9 +1641,9 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
           }
 
           if (res == BTM_SUCCESS) {
-            p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+            p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
-            if (p_dev_rec->sec_rec.bond_type != BOND_TYPE_TEMPORARY) {
+            if (p_dev_rec->bond_type != BOND_TYPE_TEMPORARY) {
               // Add all bonded device into resolving list if IRK is available.
               btm_ble_resolving_list_load_dev(*p_dev_rec);
             } else if (p_dev_rec->ble_hci_handle == HCI_INVALID_HANDLE) {
@@ -1656,8 +1653,8 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
               LOG_DEBUG(
                   "SMP over BR triggered by temporary bond has completed,"
                   " resetting the LK flags");
-              p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
-              p_dev_rec->sec_rec.ble_keys.key_type = BTM_LE_KEY_NONE;
+              p_dev_rec->sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
+              p_dev_rec->ble_keys.key_type = BTM_LE_KEY_NONE;
             }
           }
           tBTM_BD_NAME remote_name = {};
@@ -1740,12 +1737,12 @@ bool BTM_BleDataSignature(const RawAddress& bd_addr, uint8_t* p_text,
     pp = (p_buf + len);
   }
 
-  UINT32_TO_STREAM(pp, p_rec->sec_rec.ble_keys.local_counter);
-  UINT32_TO_STREAM(p_mac, p_rec->sec_rec.ble_keys.local_counter);
+  UINT32_TO_STREAM(pp, p_rec->ble_keys.local_counter);
+  UINT32_TO_STREAM(p_mac, p_rec->ble_keys.local_counter);
 
-  crypto_toolbox::aes_cmac(p_rec->sec_rec.ble_keys.lcsrk, p_buf,
-                           (uint16_t)(len + 4), BTM_CMAC_TLEN_SIZE, p_mac);
-  p_rec->sec_rec.increment_sign_counter(true);
+  crypto_toolbox::aes_cmac(p_rec->ble_keys.lcsrk, p_buf, (uint16_t)(len + 4),
+                           BTM_CMAC_TLEN_SIZE, p_mac);
+  btm_ble_increment_sign_ctr(bd_addr, true);
 
   LOG_VERBOSE("p_mac = %p", p_mac);
   LOG_VERBOSE(
@@ -1782,20 +1779,20 @@ bool BTM_BleVerifySignature(const RawAddress& bd_addr, uint8_t* p_orig,
   uint8_t p_mac[BTM_CMAC_TLEN_SIZE];
 
   if (p_rec == NULL ||
-      (p_rec && !(p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PCSRK))) {
+      (p_rec && !(p_rec->ble_keys.key_type & BTM_LE_KEY_PCSRK))) {
     LOG_ERROR("can not verify signature for unknown device");
-  } else if (counter < p_rec->sec_rec.ble_keys.counter) {
+  } else if (counter < p_rec->ble_keys.counter) {
     LOG_ERROR("signature received with out dated sign counter");
   } else if (p_orig == NULL) {
     LOG_ERROR("No signature to verify");
   } else {
     LOG_VERBOSE("rcv_cnt=%d >= expected_cnt=%d", counter,
-                p_rec->sec_rec.ble_keys.counter);
+                p_rec->ble_keys.counter);
 
-    crypto_toolbox::aes_cmac(p_rec->sec_rec.ble_keys.pcsrk, p_orig, len,
+    crypto_toolbox::aes_cmac(p_rec->ble_keys.pcsrk, p_orig, len,
                              BTM_CMAC_TLEN_SIZE, p_mac);
     if (CRYPTO_memcmp(p_mac, p_comp, BTM_CMAC_TLEN_SIZE) == 0) {
-      p_rec->sec_rec.increment_sign_counter(false);
+      btm_ble_increment_sign_ctr(bd_addr, false);
       verified = true;
     }
   }
@@ -1985,7 +1982,7 @@ std::optional<Octet16> BTM_BleGetPeerLTK(const RawAddress address) {
     return std::nullopt;
   }
 
-  return p_dev_rec->sec_rec.ble_keys.pltk;
+  return p_dev_rec->ble_keys.pltk;
 }
 
 std::optional<Octet16> BTM_BleGetPeerIRK(const RawAddress address) {
@@ -1994,12 +1991,12 @@ std::optional<Octet16> BTM_BleGetPeerIRK(const RawAddress address) {
     return std::nullopt;
   }
 
-  return p_dev_rec->sec_rec.ble_keys.irk;
+  return p_dev_rec->ble_keys.irk;
 }
 
 bool BTM_BleIsLinkKeyKnown(const RawAddress address) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(address);
-  return p_dev_rec != nullptr && p_dev_rec->sec_rec.is_le_link_key_known();
+  return p_dev_rec != nullptr && p_dev_rec->is_le_link_key_known();
 }
 
 std::optional<tBLE_BD_ADDR> BTM_BleGetIdentityAddress(
diff --git a/system/stack/btm/btm_dev.cc b/system/stack/btm/btm_dev.cc
index ead44de7ff..a3750212aa 100644
--- a/system/stack/btm/btm_dev.cc
+++ b/system/stack/btm/btm_dev.cc
@@ -57,8 +57,8 @@ constexpr char kBtmLogTag[] = "BOND";
 }
 
 static void wipe_secrets_and_remove(tBTM_SEC_DEV_REC* p_dev_rec) {
-  p_dev_rec->sec_rec.link_key.fill(0);
-  memset(&p_dev_rec->sec_rec.ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
+  p_dev_rec->link_key.fill(0);
+  memset(&p_dev_rec->ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
   list_remove(btm_sec_cb.sec_dev_rec, p_dev_rec);
 }
 
@@ -112,7 +112,7 @@ bool BTM_SecAddDevice(const RawAddress& bd_addr, DEV_CLASS dev_class,
      * bond state for an existing device here? This logic should be verified
      * as part of a larger refactor.
      */
-    p_dev_rec->sec_rec.bond_type = BOND_TYPE_UNKNOWN;
+    p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
   }
 
   if (dev_class) memcpy(p_dev_rec->dev_class, dev_class, DEV_CLASS_LEN);
@@ -122,28 +122,28 @@ bool BTM_SecAddDevice(const RawAddress& bd_addr, DEV_CLASS dev_class,
   if (bd_name && bd_name[0]) {
     LOG_DEBUG("  Remote name known for device:%s name:%s",
               ADDRESS_TO_LOGGABLE_CSTR(bd_addr), bd_name);
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_NAME_KNOWN;
+    p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
     strlcpy((char*)p_dev_rec->sec_bd_name, (char*)bd_name,
             BTM_MAX_REM_BD_NAME_LEN + 1);
   }
 
   if (p_link_key) {
     LOG_DEBUG("  Link key known for device:%s", ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
-    p_dev_rec->sec_rec.link_key = *p_link_key;
-    p_dev_rec->sec_rec.link_key_type = key_type;
-    p_dev_rec->sec_rec.pin_code_length = pin_length;
+    p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
+    p_dev_rec->link_key = *p_link_key;
+    p_dev_rec->link_key_type = key_type;
+    p_dev_rec->pin_code_length = pin_length;
 
     if (pin_length >= 16 || key_type == BTM_LKEY_TYPE_AUTH_COMB ||
         key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
       // Set the flag if the link key was made by using either a 16 digit
       // pin or MITM.
-      p_dev_rec->sec_rec.sec_flags |=
+      p_dev_rec->sec_flags |=
           BTM_SEC_16_DIGIT_PIN_AUTHED | BTM_SEC_LINK_KEY_AUTHED;
     }
   }
 
-  p_dev_rec->sec_rec.rmt_io_caps = BTM_IO_CAP_OUT;
+  p_dev_rec->rmt_io_caps = BTM_IO_CAP_OUT;
   p_dev_rec->device_type |= BT_DEVICE_TYPE_BREDR;
 
   return true;
@@ -171,8 +171,8 @@ bool BTM_SecDeleteDevice(const RawAddress& bd_addr) {
   }
 
   /* Invalidate bonded status */
-  p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
-  p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_LINK_KEY_KNOWN;
+  p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
+  p_dev_rec->sec_flags &= ~BTM_SEC_LE_LINK_KEY_KNOWN;
 
   if (BTM_IsAclConnectionUp(bd_addr, BT_TRANSPORT_LE) ||
       BTM_IsAclConnectionUp(bd_addr, BT_TRANSPORT_BR_EDR)) {
@@ -195,7 +195,7 @@ bool BTM_SecDeleteDevice(const RawAddress& bd_addr) {
   }
 
   const auto device_type = p_dev_rec->device_type;
-  const auto bond_type = p_dev_rec->sec_rec.bond_type;
+  const auto bond_type = p_dev_rec->bond_type;
 
   /* Clear out any saved BLE keys */
   btm_sec_clear_ble_keys(p_dev_rec);
@@ -223,8 +223,8 @@ void BTM_SecClearSecurityFlags(const RawAddress& bd_addr) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
   if (p_dev_rec == NULL) return;
 
-  p_dev_rec->sec_rec.sec_flags = 0;
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_flags = 0;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
   p_dev_rec->sm4 = BTM_SM4_UNKNOWN;
 }
 
@@ -401,7 +401,7 @@ tBTM_SEC_DEV_REC* btm_find_dev(const RawAddress& bd_addr) {
 
 static bool has_lenc_and_address_is_equal(void* data, void* context) {
   tBTM_SEC_DEV_REC* p_dev_rec = static_cast<tBTM_SEC_DEV_REC*>(data);
-  if (!(p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_LENC)) return true;
+  if (!(p_dev_rec->ble_keys.key_type & BTM_LE_KEY_LENC)) return true;
 
   return is_address_equal(data, context);
 }
@@ -453,16 +453,15 @@ void btm_consolidate_dev(tBTM_SEC_DEV_REC* p_target_rec) {
     if (p_dev_rec->bd_addr == p_target_rec->bd_addr) {
       memcpy(p_target_rec, p_dev_rec, sizeof(tBTM_SEC_DEV_REC));
       p_target_rec->ble = temp_rec.ble;
-      p_target_rec->sec_rec.ble_keys = temp_rec.sec_rec.ble_keys;
       p_target_rec->ble_hci_handle = temp_rec.ble_hci_handle;
-      p_target_rec->sec_rec.enc_key_size = temp_rec.sec_rec.enc_key_size;
+      p_target_rec->enc_key_size = temp_rec.enc_key_size;
       p_target_rec->conn_params = temp_rec.conn_params;
       p_target_rec->device_type |= temp_rec.device_type;
-      p_target_rec->sec_rec.sec_flags |= temp_rec.sec_rec.sec_flags;
+      p_target_rec->sec_flags |= temp_rec.sec_flags;
 
-      p_target_rec->sec_rec.new_encryption_key_is_p256 =
-          temp_rec.sec_rec.new_encryption_key_is_p256;
-      p_target_rec->sec_rec.bond_type = temp_rec.sec_rec.bond_type;
+      p_target_rec->new_encryption_key_is_p256 =
+          temp_rec.new_encryption_key_is_p256;
+      p_target_rec->bond_type = temp_rec.bond_type;
 
       /* remove the combined record */
       wipe_secrets_and_remove(p_dev_rec);
@@ -596,7 +595,7 @@ static tBTM_SEC_DEV_REC* btm_find_oldest_dev_rec(void) {
     tBTM_SEC_DEV_REC* p_dev_rec =
         static_cast<tBTM_SEC_DEV_REC*>(list_node(node));
 
-    if ((p_dev_rec->sec_rec.sec_flags &
+    if ((p_dev_rec->sec_flags &
          (BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LE_LINK_KEY_KNOWN)) == 0) {
       // Device is not paired
       if (p_dev_rec->timestamp < ts_oldest) {
@@ -643,10 +642,10 @@ tBTM_SEC_DEV_REC* btm_sec_allocate_dev_rec(void) {
   list_append(btm_sec_cb.sec_dev_rec, p_dev_rec);
 
   // Initialize defaults
-  p_dev_rec->sec_rec.sec_flags = BTM_SEC_IN_USE;
-  p_dev_rec->sec_rec.bond_type = BOND_TYPE_UNKNOWN;
+  p_dev_rec->sec_flags = BTM_SEC_IN_USE;
+  p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
   p_dev_rec->timestamp = btm_sec_cb.dev_rec_count++;
-  p_dev_rec->sec_rec.rmt_io_caps = BTM_IO_CAP_UNKNOWN;
+  p_dev_rec->rmt_io_caps = BTM_IO_CAP_UNKNOWN;
   p_dev_rec->suggested_tx_octets = 0;
 
   return p_dev_rec;
@@ -667,7 +666,7 @@ tBTM_BOND_TYPE btm_get_bond_type_dev(const RawAddress& bd_addr) {
 
   if (p_dev_rec == NULL) return BOND_TYPE_UNKNOWN;
 
-  return p_dev_rec->sec_rec.bond_type;
+  return p_dev_rec->bond_type;
 }
 
 /*******************************************************************************
@@ -686,7 +685,7 @@ bool btm_set_bond_type_dev(const RawAddress& bd_addr,
 
   if (p_dev_rec == NULL) return false;
 
-  p_dev_rec->sec_rec.bond_type = bond_type;
+  p_dev_rec->bond_type = bond_type;
   return true;
 }
 
@@ -791,7 +790,7 @@ const tBLE_BD_ADDR BTM_Sec_GetAddressWithType(const RawAddress& bd_addr) {
 
 bool BTM_IsRemoteNameKnown(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
-  return (p_dev_rec == nullptr) ? false : p_dev_rec->sec_rec.is_name_known();
+  return (p_dev_rec == nullptr) ? false : p_dev_rec->is_name_known();
 }
 
 namespace bluetooth {
diff --git a/system/stack/btm/btm_devctl.cc b/system/stack/btm/btm_devctl.cc
index 61a208b246..a89c5788b0 100644
--- a/system/stack/btm/btm_devctl.cc
+++ b/system/stack/btm/btm_devctl.cc
@@ -162,7 +162,7 @@ void BTM_db_reset(void) {
 
 static bool set_sec_state_idle(void* data, void* context) {
   tBTM_SEC_DEV_REC* p_dev_rec = static_cast<tBTM_SEC_DEV_REC*>(data);
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
   return true;
 }
 
diff --git a/system/stack/btm/btm_sec.cc b/system/stack/btm/btm_sec.cc
index 67e643ebb3..020e2803f1 100644
--- a/system/stack/btm/btm_sec.cc
+++ b/system/stack/btm/btm_sec.cc
@@ -105,6 +105,9 @@ static void btm_sec_collision_timeout(void* data);
 static void btm_restore_mode(void);
 static void btm_sec_pairing_timeout(void* data);
 static tBTM_STATUS btm_sec_dd_create_conn(tBTM_SEC_DEV_REC* p_dev_rec);
+static void btm_sec_change_pairing_state(tBTM_PAIRING_STATE new_state);
+
+static const char* btm_pair_state_descr(tBTM_PAIRING_STATE state);
 
 static void btm_sec_check_pending_reqs(void);
 static bool btm_sec_queue_mx_request(const RawAddress& bd_addr, uint16_t psm,
@@ -193,7 +196,7 @@ void NotifyBondingCanceled(tBTM_STATUS btm_status) {
  *
  ******************************************************************************/
 static bool btm_dev_authenticated(const tBTM_SEC_DEV_REC* p_dev_rec) {
-  return p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED;
+  return p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED;
 }
 
 /*******************************************************************************
@@ -206,7 +209,7 @@ static bool btm_dev_authenticated(const tBTM_SEC_DEV_REC* p_dev_rec) {
  *
  ******************************************************************************/
 static bool btm_dev_encrypted(const tBTM_SEC_DEV_REC* p_dev_rec) {
-  return p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED;
+  return p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED;
 }
 
 /*******************************************************************************
@@ -220,14 +223,14 @@ static bool btm_dev_encrypted(const tBTM_SEC_DEV_REC* p_dev_rec) {
  ******************************************************************************/
 static bool btm_dev_16_digit_authenticated(const tBTM_SEC_DEV_REC* p_dev_rec) {
   // BTM_SEC_16_DIGIT_PIN_AUTHED is set if MITM or 16 digit pin is used
-  return p_dev_rec->sec_rec.sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED;
+  return p_dev_rec->sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED;
 }
 
 static bool is_sec_state_equal(void* data, void* context) {
   tBTM_SEC_DEV_REC* p_dev_rec = static_cast<tBTM_SEC_DEV_REC*>(data);
   uint8_t* state = static_cast<uint8_t*>(context);
 
-  if (p_dev_rec->sec_rec.sec_state == *state) return false;
+  if (p_dev_rec->sec_state == *state) return false;
 
   return true;
 }
@@ -265,8 +268,8 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r
                                                  bool locally_initiated,
                                                  uint16_t security_req) {
   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&
-         p_dev_rec->sec_rec.is_device_authenticated() &&
-         p_dev_rec->sec_rec.is_bond_type_temporary();
+    p_dev_rec->is_device_authenticated() &&
+    p_dev_rec->is_bond_type_temporary();
 }
 
 /*******************************************************************************
@@ -349,19 +352,27 @@ bool BTM_SecDeleteRmtNameNotifyCallback(tBTM_RMT_NAME_CALLBACK* p_callback) {
 }
 
 bool BTM_IsEncrypted(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
-  return btm_sec_cb.IsDeviceEncrypted(bd_addr, transport);
+  uint8_t flags = 0;
+  BTM_GetSecurityFlagsByTransport(bd_addr, &flags, transport);
+  return (flags & BTM_SEC_FLAG_ENCRYPTED) != 0;
 }
 
 bool BTM_IsLinkKeyAuthed(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
-  return btm_sec_cb.IsLinkKeyAuthenticated(bd_addr, transport);
+  uint8_t flags = 0;
+  BTM_GetSecurityFlagsByTransport(bd_addr, &flags, transport);
+  return (flags & BTM_SEC_FLAG_LKEY_AUTHED) != 0;
 }
 
 bool BTM_IsLinkKeyKnown(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
-  return btm_sec_cb.IsLinkKeyKnown(bd_addr, transport);
+  uint8_t flags = 0;
+  BTM_GetSecurityFlagsByTransport(bd_addr, &flags, transport);
+  return (flags & BTM_SEC_FLAG_LKEY_KNOWN) != 0;
 }
 
 bool BTM_IsAuthenticated(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
-  return btm_sec_cb.IsDeviceAuthenticated(bd_addr, transport);
+  uint8_t flags = 0;
+  BTM_GetSecurityFlagsByTransport(bd_addr, &flags, transport);
+  return (flags & BTM_SEC_AUTHENTICATED) != 0;
 }
 
 bool BTM_CanReadDiscoverableCharacteristics(const RawAddress& bd_addr) {
@@ -376,6 +387,33 @@ bool BTM_CanReadDiscoverableCharacteristics(const RawAddress& bd_addr) {
   }
 }
 
+/*******************************************************************************
+ *
+ * Function         BTM_GetSecurityFlagsByTransport
+ *
+ * Description      Get security flags for the device on a particular transport
+ *
+ * Returns          bool    true or false is device found
+ *
+ ******************************************************************************/
+bool BTM_GetSecurityFlagsByTransport(const RawAddress& bd_addr,
+                                     uint8_t* p_sec_flags,
+                                     tBT_TRANSPORT transport) {
+  tBTM_SEC_DEV_REC* p_dev_rec;
+
+  p_dev_rec = btm_find_dev(bd_addr);
+  if (p_dev_rec != NULL) {
+    if (transport == BT_TRANSPORT_BR_EDR)
+      *p_sec_flags = (uint8_t)p_dev_rec->sec_flags;
+    else
+      *p_sec_flags = (uint8_t)(p_dev_rec->sec_flags >> 8);
+
+    return (true);
+  }
+  LOG_ERROR("BTM_GetSecurityFlags false");
+  return (false);
+}
+
 /*******************************************************************************
  *
  * Function         BTM_SetPinType
@@ -401,6 +439,8 @@ void BTM_SetPinType(uint8_t pin_type, PIN_CODE pin_code, uint8_t pin_code_len) {
   memcpy(btm_sec_cb.cfg.pin_code, pin_code, pin_code_len);
 }
 
+#define BTM_NO_AVAIL_SEC_SERVICES ((uint16_t)0xffff)
+
 /*******************************************************************************
  *
  * Function         BTM_SetSecurityLevel
@@ -424,8 +464,119 @@ void BTM_SetPinType(uint8_t pin_type, PIN_CODE pin_code, uint8_t pin_code_len) {
 bool BTM_SetSecurityLevel(bool is_originator, const char* p_name,
                           uint8_t service_id, uint16_t sec_level, uint16_t psm,
                           uint32_t mx_proto_id, uint32_t mx_chan_id) {
-  return btm_sec_cb.AddService(is_originator, p_name, service_id, sec_level,
-                               psm, mx_proto_id, mx_chan_id);
+  tBTM_SEC_SERV_REC* p_srec;
+  uint16_t index;
+  uint16_t first_unused_record = BTM_NO_AVAIL_SEC_SERVICES;
+  bool record_allocated = false;
+
+  LOG_VERBOSE("sec: 0x%x", sec_level);
+
+  /* See if the record can be reused (same service name, psm, mx_proto_id,
+     service_id, and mx_chan_id), or obtain the next unused record */
+
+  p_srec = &btm_sec_cb.sec_serv_rec[0];
+
+  for (index = 0; index < BTM_SEC_MAX_SERVICE_RECORDS; index++, p_srec++) {
+    /* Check if there is already a record for this service */
+    if (p_srec->security_flags & BTM_SEC_IN_USE) {
+      if (p_srec->psm == psm && p_srec->mx_proto_id == mx_proto_id &&
+          service_id == p_srec->service_id && p_name &&
+          (!strncmp(p_name, (char*)p_srec->orig_service_name,
+                    /* strlcpy replaces end char with termination char*/
+                    BT_MAX_SERVICE_NAME_LEN - 1) ||
+           !strncmp(p_name, (char*)p_srec->term_service_name,
+                    /* strlcpy replaces end char with termination char*/
+                    BT_MAX_SERVICE_NAME_LEN - 1))) {
+        record_allocated = true;
+        break;
+      }
+    }
+    /* Mark the first available service record */
+    else if (!record_allocated) {
+      memset(p_srec, 0, sizeof(tBTM_SEC_SERV_REC));
+      record_allocated = true;
+      first_unused_record = index;
+    }
+  }
+
+  if (!record_allocated) {
+    LOG_WARN("BTM_SEC_REG: Out of Service Records (%d)",
+             BTM_SEC_MAX_SERVICE_RECORDS);
+    return (record_allocated);
+  }
+
+  /* Process the request if service record is valid */
+  /* If a duplicate service wasn't found, use the first available */
+  if (index >= BTM_SEC_MAX_SERVICE_RECORDS) {
+    index = first_unused_record;
+    p_srec = &btm_sec_cb.sec_serv_rec[index];
+  }
+
+  p_srec->psm = psm;
+  p_srec->service_id = service_id;
+  p_srec->mx_proto_id = mx_proto_id;
+
+  if (is_originator) {
+    p_srec->orig_mx_chan_id = mx_chan_id;
+    strlcpy((char*)p_srec->orig_service_name, p_name,
+            BT_MAX_SERVICE_NAME_LEN + 1);
+    /* clear out the old setting, just in case it exists */
+    {
+      p_srec->security_flags &=
+          ~(BTM_SEC_OUT_ENCRYPT | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_MITM);
+    }
+
+    /* Parameter validation.  Originator should not set requirements for
+     * incoming connections */
+    sec_level &= ~(BTM_SEC_IN_ENCRYPT | BTM_SEC_IN_AUTHENTICATE |
+                   BTM_SEC_IN_MITM | BTM_SEC_IN_MIN_16_DIGIT_PIN);
+
+    if (btm_sec_cb.security_mode == BTM_SEC_MODE_SP ||
+        btm_sec_cb.security_mode == BTM_SEC_MODE_SC) {
+      if (sec_level & BTM_SEC_OUT_AUTHENTICATE) sec_level |= BTM_SEC_OUT_MITM;
+    }
+
+    /* Make sure the authenticate bit is set, when encrypt bit is set */
+    if (sec_level & BTM_SEC_OUT_ENCRYPT) sec_level |= BTM_SEC_OUT_AUTHENTICATE;
+
+    /* outgoing connections usually set the security level right before
+     * the connection is initiated.
+     * set it to be the outgoing service */
+    btm_sec_cb.p_out_serv = p_srec;
+  } else {
+    p_srec->term_mx_chan_id = mx_chan_id;
+    strlcpy((char*)p_srec->term_service_name, p_name,
+            BT_MAX_SERVICE_NAME_LEN + 1);
+    /* clear out the old setting, just in case it exists */
+    {
+      p_srec->security_flags &=
+          ~(BTM_SEC_IN_ENCRYPT | BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_MITM |
+            BTM_SEC_IN_MIN_16_DIGIT_PIN);
+    }
+
+    /* Parameter validation.  Acceptor should not set requirements for outgoing
+     * connections */
+    sec_level &=
+        ~(BTM_SEC_OUT_ENCRYPT | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_MITM);
+
+    if (btm_sec_cb.security_mode == BTM_SEC_MODE_SP ||
+        btm_sec_cb.security_mode == BTM_SEC_MODE_SC) {
+      if (sec_level & BTM_SEC_IN_AUTHENTICATE) sec_level |= BTM_SEC_IN_MITM;
+    }
+
+    /* Make sure the authenticate bit is set, when encrypt bit is set */
+    if (sec_level & BTM_SEC_IN_ENCRYPT) sec_level |= BTM_SEC_IN_AUTHENTICATE;
+  }
+
+  p_srec->security_flags |= (uint16_t)(sec_level | BTM_SEC_IN_USE);
+
+  LOG_DEBUG(
+      "[%d]: id:%d, is_orig:%s psm:0x%04x proto_id:%d chan_id:%d"
+      "  : sec:0x%x service_name:[%s] (up to %d chars saved)",
+      index, service_id, logbool(is_originator).c_str(), psm, mx_proto_id,
+      mx_chan_id, p_srec->security_flags, p_name, BT_MAX_SERVICE_NAME_LEN);
+
+  return (record_allocated);
 }
 
 /*******************************************************************************
@@ -447,7 +598,22 @@ bool BTM_SetSecurityLevel(bool is_originator, const char* p_name,
  *
  ******************************************************************************/
 uint8_t BTM_SecClrService(uint8_t service_id) {
-  return btm_sec_cb.RemoveServiceById(service_id);
+  tBTM_SEC_SERV_REC* p_srec = &btm_sec_cb.sec_serv_rec[0];
+  uint8_t num_freed = 0;
+  int i;
+
+  for (i = 0; i < BTM_SEC_MAX_SERVICE_RECORDS; i++, p_srec++) {
+    /* Delete services with specified name (if in use and not SDP) */
+    if ((p_srec->security_flags & BTM_SEC_IN_USE) &&
+        (p_srec->psm != BT_PSM_SDP) &&
+        (!service_id || (service_id == p_srec->service_id))) {
+      LOG_VERBOSE("BTM_SEC_CLR[%d]: id %d", i, service_id);
+      p_srec->security_flags = 0;
+      num_freed++;
+    }
+  }
+
+  return (num_freed);
 }
 
 /*******************************************************************************
@@ -467,7 +633,21 @@ uint8_t BTM_SecClrService(uint8_t service_id) {
  *
  ******************************************************************************/
 uint8_t BTM_SecClrServiceByPsm(uint16_t psm) {
-  return btm_sec_cb.RemoveServiceByPsm(psm);
+  tBTM_SEC_SERV_REC* p_srec = &btm_sec_cb.sec_serv_rec[0];
+  uint8_t num_freed = 0;
+  int i;
+
+  for (i = 0; i < BTM_SEC_MAX_SERVICE_RECORDS; i++, p_srec++) {
+    /* Delete services with specified name (if in use and not SDP) */
+    if ((p_srec->security_flags & BTM_SEC_IN_USE) && (p_srec->psm == psm)) {
+      LOG_VERBOSE("BTM_SEC_CLR[%d]: id %d ", i, p_srec->service_id);
+      p_srec->security_flags = 0;
+      num_freed++;
+    }
+  }
+  LOG_VERBOSE("BTM_SecClrServiceByPsm psm:0x%x num_freed:%d", psm, num_freed);
+
+  return (num_freed);
 }
 
 /*******************************************************************************
@@ -492,8 +672,8 @@ void BTM_PINCodeReply(const RawAddress& bd_addr, tBTM_STATUS res,
   LOG_VERBOSE(
       "BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  "
       "Result:%d",
-      tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
-      btm_sec_cb.pairing_flags, pin_len, res);
+      btm_pair_state_descr(btm_sec_cb.pairing_state), btm_sec_cb.pairing_flags,
+      pin_len, res);
 
   /* If timeout already expired or has been canceled, ignore the reply */
   if (btm_sec_cb.pairing_state != BTM_PAIR_STATE_WAIT_LOCAL_PIN) {
@@ -523,20 +703,20 @@ void BTM_PINCodeReply(const RawAddress& bd_addr, tBTM_STATUS res,
          (btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE))) {
       /* use BTM_PAIR_STATE_WAIT_AUTH_COMPLETE to report authentication failed
        * event */
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
       acl_set_disconnect_reason(HCI_ERR_HOST_REJECT_SECURITY);
 
       btsnd_hcic_pin_code_neg_reply(bd_addr);
     } else {
-      p_dev_rec->sec_rec.security_required = BTM_SEC_NONE;
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      p_dev_rec->security_required = BTM_SEC_NONE;
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
     }
     return;
   }
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
-  p_dev_rec->sec_rec.pin_code_length = pin_len;
+  p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
+  p_dev_rec->pin_code_length = pin_len;
   if (pin_len >= 16) {
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+    p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
   }
 
   if ((btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
@@ -561,24 +741,24 @@ void BTM_PINCodeReply(const RawAddress& bd_addr, tBTM_STATUS res,
       /* we change state little bit early so btm_sec_connected() will originate
        * connection */
       /*   when existing ACL link is down completely */
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
     }
     /* if we already accepted incoming connection from pairing device */
     else if (p_dev_rec->sm4 & BTM_SM4_CONN_PEND) {
       LOG_WARN(
           "BTM_PINCodeReply(): link is connecting so wait pin code request "
           "from peer");
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
     } else if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED) {
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
-      p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
+      p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;
 
       NotifyBondingChange(*p_dev_rec, HCI_ERR_AUTH_FAILURE);
     }
     return;
   }
 
-  btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+  btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
   acl_set_disconnect_reason(HCI_SUCCESS);
 
   btsnd_hcic_pin_code_req_reply(bd_addr, pin_len, p_pin);
@@ -607,7 +787,7 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
   /* Other security process is in progress */
   if (btm_sec_cb.pairing_state != BTM_PAIR_STATE_IDLE) {
     LOG_ERROR("BTM_SecBond: already busy in state: %s",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state));
+              btm_pair_state_descr(btm_sec_cb.pairing_state));
     return (BTM_WRONG_MODE);
   }
 
@@ -622,15 +802,15 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
     return (BTM_NO_RESOURCES);
   }
 
-  LOG_VERBOSE("before update sec_flags=0x%x", p_dev_rec->sec_rec.sec_flags);
+  LOG_VERBOSE("before update sec_flags=0x%x", p_dev_rec->sec_flags);
 
   /* Finished if connection is active and already paired */
   if (((p_dev_rec->hci_handle != HCI_INVALID_HANDLE) &&
        transport == BT_TRANSPORT_BR_EDR &&
-       (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) ||
+       (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) ||
       ((p_dev_rec->ble_hci_handle != HCI_INVALID_HANDLE) &&
        transport == BT_TRANSPORT_LE &&
-       (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_AUTHENTICATED))) {
+       (p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED))) {
     LOG_WARN("BTM_SecBond -> Already Paired");
     return (BTM_SUCCESS);
   }
@@ -645,7 +825,7 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
 
   btm_sec_cb.pairing_flags = BTM_PAIR_FLAGS_WE_STARTED_DD;
 
-  p_dev_rec->sec_rec.security_required = BTM_SEC_OUT_AUTHENTICATE;
+  p_dev_rec->security_required = BTM_SEC_OUT_AUTHENTICATE;
   p_dev_rec->is_originator = true;
 
   BTM_LogHistory(kBtmLogTag, bd_addr, "Bonding initiated",
@@ -653,12 +833,12 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
 
   if (transport == BT_TRANSPORT_LE) {
     btm_ble_init_pseudo_addr(p_dev_rec, bd_addr);
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_MASK;
+    p_dev_rec->sec_flags &= ~BTM_SEC_LE_MASK;
 
     if (SMP_Pair(bd_addr, addr_type) == SMP_STARTED) {
       btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_LE_ACTIVE;
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+      p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
       return BTM_CMD_STARTED;
     }
 
@@ -666,11 +846,11 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
     return (BTM_NO_RESOURCES);
   }
 
-  p_dev_rec->sec_rec.sec_flags &=
+  p_dev_rec->sec_flags &=
       ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED |
         BTM_SEC_ROLE_SWITCHED | BTM_SEC_LINK_KEY_AUTHED);
 
-  LOG_VERBOSE("after update sec_flags=0x%x", p_dev_rec->sec_rec.sec_flags);
+  LOG_VERBOSE("after update sec_flags=0x%x", p_dev_rec->sec_flags);
   if (!controller_get_interface()->supports_simple_pairing()) {
     /* The special case when we authenticate keyboard.  Set pin type to fixed */
     /* It would be probably better to do it from the application, but it is */
@@ -688,14 +868,14 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
               p_dev_rec->sm4, p_dev_rec->hci_handle);
 
 #if (BTM_SEC_FORCE_RNR_FOR_DBOND == TRUE)
-  p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_NAME_KNOWN;
+  p_dev_rec->sec_flags &= ~BTM_SEC_NAME_KNOWN;
 #endif
 
   /* If connection already exists... */
   if (BTM_IsAclConnectionUpAndHandleValid(bd_addr, transport)) {
     btm_sec_wait_and_start_authentication(p_dev_rec);
 
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
 
     /* Mark lcb as bonding */
     l2cu_update_lcb_4_bonding(bd_addr, true);
@@ -715,16 +895,16 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
       /* we are not accepting connection request from peer
        * -> RNR (to learn if peer is 2.1)
        * RNR when no ACL causes HCI_RMT_HOST_SUP_FEAT_NOTIFY_EVT */
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_GET_REM_NAME);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_GET_REM_NAME);
       status = BTM_ReadRemoteDeviceName(bd_addr, NULL, BT_TRANSPORT_BR_EDR);
     } else {
       /* We are accepting connection request from peer */
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
       status = BTM_CMD_STARTED;
     }
     LOG_VERBOSE("State:%s sm4: 0x%x sec_state:%d",
-                tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
-                p_dev_rec->sm4, p_dev_rec->sec_rec.sec_state);
+                btm_pair_state_descr(btm_sec_cb.pairing_state), p_dev_rec->sm4,
+                p_dev_rec->sec_state);
   } else {
     /* both local and peer are 2.1  */
     status = btm_sec_dd_create_conn(p_dev_rec);
@@ -733,7 +913,7 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
   if (status != BTM_CMD_STARTED) {
     LOG_ERROR("BTM_ReadRemoteDeviceName or btm_sec_dd_create_conn error: 0x%x",
               (int)status);
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
   }
 
   return status;
@@ -793,7 +973,7 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
   tBTM_SEC_DEV_REC* p_dev_rec;
 
   LOG_VERBOSE("BTM_SecBondCancel()  State: %s flags:0x%x",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
+              btm_pair_state_descr(btm_sec_cb.pairing_state),
               btm_sec_cb.pairing_flags);
   p_dev_rec = btm_find_dev(bd_addr);
   if (!p_dev_rec || btm_sec_cb.pairing_bda != bd_addr) {
@@ -801,7 +981,7 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
   }
 
   if (btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_LE_ACTIVE) {
-    if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+    if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
       LOG_VERBOSE("Cancel LE pairing");
       if (SMP_PairCancel(bd_addr)) {
         return BTM_CMD_STARTED;
@@ -811,7 +991,7 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
   }
 
   LOG_VERBOSE("hci_handle:0x%x sec_state:%d", p_dev_rec->hci_handle,
-              p_dev_rec->sec_rec.sec_state);
+              p_dev_rec->sec_state);
   if (BTM_PAIR_STATE_WAIT_LOCAL_PIN == btm_sec_cb.pairing_state &&
       BTM_PAIR_FLAGS_WE_STARTED_DD & btm_sec_cb.pairing_flags) {
     /* pre-fetching pin for dedicated bonding */
@@ -825,8 +1005,8 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
     /* If the HCI link is up */
     if (p_dev_rec->hci_handle != HCI_INVALID_HANDLE) {
       /* If some other thread disconnecting, we do not send second command */
-      if ((p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_DISCONNECTING) ||
-          (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH))
+      if ((p_dev_rec->sec_state == BTM_SEC_STATE_DISCONNECTING) ||
+          (p_dev_rec->sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH))
         return (BTM_CMD_STARTED);
 
       /* If the HCI link was set up by Bonding process */
@@ -874,9 +1054,8 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
 tBTM_LINK_KEY_TYPE BTM_SecGetDeviceLinkKeyType(const RawAddress& bd_addr) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
 
-  if ((p_dev_rec != NULL) &&
-      (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
-    return p_dev_rec->sec_rec.link_key_type;
+  if ((p_dev_rec != NULL) && (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
+    return p_dev_rec->link_key_type;
   }
   return BTM_LKEY_TYPE_IGNORE;
 }
@@ -933,7 +1112,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         }
         return BTM_WRONG_MODE;
       }
-      if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED) {
+      if (p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED) {
         LOG_DEBUG(
             "Security Manager: BTM_SetEncryption already encrypted peer:%s "
             "transport:%s",
@@ -960,7 +1139,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         }
         return BTM_WRONG_MODE;
       }
-      if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_ENCRYPTED) {
+      if (p_dev_rec->sec_flags & BTM_SEC_LE_ENCRYPTED) {
         LOG_DEBUG(
             "Security Manager: BTM_SetEncryption already encrypted peer:%s "
             "transport:%s",
@@ -982,7 +1161,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
   /* Enqueue security request if security is active */
   if (bluetooth::common::init_flags::encryption_in_busy_state_is_enabled()) {
     bool enqueue = false;
-    switch (p_dev_rec->sec_rec.sec_state) {
+    switch (p_dev_rec->sec_state) {
       case BTM_SEC_STATE_AUTHENTICATING:
       case BTM_SEC_STATE_DISCONNECTING_BOTH:
         /* Applicable for both transports */
@@ -1004,7 +1183,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         break;
 
       default:
-        if (p_dev_rec->sec_rec.p_callback != nullptr) {
+        if (p_dev_rec->p_callback != nullptr) {
           enqueue = true;
         }
         break;
@@ -1012,14 +1191,13 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
 
     if (enqueue) {
       LOG_WARN("Security Manager: Enqueue request in state:%s",
-               security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+               security_state_text(p_dev_rec->sec_state).c_str());
       btm_sec_queue_encrypt_request(bd_addr, transport, p_callback, p_ref_data,
                                     sec_act);
       return BTM_CMD_STARTED;
     }
   } else {
-    if (p_dev_rec->sec_rec.p_callback ||
-        (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_IDLE)) {
+    if (p_dev_rec->p_callback || (p_dev_rec->sec_state != BTM_SEC_STATE_IDLE)) {
       LOG_WARN("Security Manager: BTM_SetEncryption busy, enqueue request");
       btm_sec_queue_encrypt_request(bd_addr, transport, p_callback, p_ref_data,
                                     sec_act);
@@ -1028,9 +1206,9 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
     }
   }
 
-  p_dev_rec->sec_rec.p_callback = p_callback;
-  p_dev_rec->sec_rec.p_ref_data = p_ref_data;
-  p_dev_rec->sec_rec.security_required |=
+  p_dev_rec->p_callback = p_callback;
+  p_dev_rec->p_ref_data = p_ref_data;
+  p_dev_rec->security_required |=
       (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT);
   p_dev_rec->is_originator = false;
 
@@ -1038,9 +1216,9 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
       "Security Manager: BTM_SetEncryption classic_handle:0x%04x "
       "ble_handle:0x%04x state:%d flags:0x%x "
       "required:0x%x p_callback=%c",
-      p_dev_rec->hci_handle, p_dev_rec->ble_hci_handle,
-      p_dev_rec->sec_rec.sec_state, p_dev_rec->sec_rec.sec_flags,
-      p_dev_rec->sec_rec.security_required, (p_callback) ? 'T' : 'F');
+      p_dev_rec->hci_handle, p_dev_rec->ble_hci_handle, p_dev_rec->sec_state,
+      p_dev_rec->sec_flags, p_dev_rec->security_required,
+      (p_callback) ? 'T' : 'F');
 
   tBTM_STATUS rc = BTM_SUCCESS;
   switch (transport) {
@@ -1073,11 +1251,10 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         LOG_DEBUG("Executing encryption callback peer:%s transport:%s",
                   ADDRESS_TO_LOGGABLE_CSTR(bd_addr),
                   bt_transport_text(transport).c_str());
-        p_dev_rec->sec_rec.p_callback = nullptr;
-        do_in_main_thread(
-            FROM_HERE,
-            base::BindOnce(p_callback, std::move(owned_bd_addr), transport,
-                           p_dev_rec->sec_rec.p_ref_data, rc));
+        p_dev_rec->p_callback = nullptr;
+        do_in_main_thread(FROM_HERE,
+                          base::BindOnce(p_callback, std::move(owned_bd_addr),
+                                         transport, p_dev_rec->p_ref_data, rc));
       }
       break;
   }
@@ -1086,9 +1263,8 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
 
 bool BTM_SecIsSecurityPending(const RawAddress& bd_addr) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
-  return p_dev_rec &&
-         (p_dev_rec->sec_rec.is_security_state_encrypting() ||
-          p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING);
+  return p_dev_rec && (p_dev_rec->is_security_state_encrypting() ||
+                       p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING);
 }
 
 /*******************************************************************************
@@ -1099,7 +1275,7 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
                                                uint16_t conn_handle,
                                                std::string comment) {
   const tSECURITY_STATE old_state =
-      static_cast<tSECURITY_STATE>(p_dev_rec->sec_rec.sec_state);
+      static_cast<tSECURITY_STATE>(p_dev_rec->sec_state);
   const tBTM_STATUS status = BTM_CMD_STARTED;
 
   /* send HCI_Disconnect on a transport only once */
@@ -1110,7 +1286,7 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
         return status;
       }
       // Prepare to send disconnect on le transport
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
+      p_dev_rec->sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
       break;
 
     case BTM_SEC_STATE_DISCONNECTING_BLE:
@@ -1119,7 +1295,7 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
         return status;
       }
       // Prepare to send disconnect on classic transport
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
+      p_dev_rec->sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
       break;
 
     case BTM_SEC_STATE_DISCONNECTING_BOTH:
@@ -1127,9 +1303,9 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
       return status;
 
     default:
-      p_dev_rec->sec_rec.sec_state = (conn_handle == p_dev_rec->hci_handle)
-                                         ? BTM_SEC_STATE_DISCONNECTING
-                                         : BTM_SEC_STATE_DISCONNECTING_BLE;
+      p_dev_rec->sec_state = (conn_handle == p_dev_rec->hci_handle)
+                                 ? BTM_SEC_STATE_DISCONNECTING
+                                 : BTM_SEC_STATE_DISCONNECTING_BLE;
 
       break;
   }
@@ -1155,7 +1331,7 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
  ******************************************************************************/
 void BTM_ConfirmReqReply(tBTM_STATUS res, const RawAddress& bd_addr) {
   LOG_VERBOSE("BTM_ConfirmReqReply() State: %s  Res: %u",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), res);
+              btm_pair_state_descr(btm_sec_cb.pairing_state), res);
 
   /* If timeout already expired or has been canceled, ignore the reply */
   if ((btm_sec_cb.pairing_state != BTM_PAIR_STATE_WAIT_NUMERIC_CONFIRM) ||
@@ -1163,7 +1339,7 @@ void BTM_ConfirmReqReply(tBTM_STATUS res, const RawAddress& bd_addr) {
     LOG_WARN(
         "Unexpected pairing confirm for %s, pairing_state: %s, pairing_bda: %s",
         ADDRESS_TO_LOGGABLE_CSTR(bd_addr),
-        tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
+        btm_pair_state_descr(btm_sec_cb.pairing_state),
         ADDRESS_TO_LOGGABLE_CSTR(btm_sec_cb.pairing_bda));
     return;
   }
@@ -1171,7 +1347,7 @@ void BTM_ConfirmReqReply(tBTM_STATUS res, const RawAddress& bd_addr) {
   BTM_LogHistory(kBtmLogTag, bd_addr, "Confirm reply",
                  base::StringPrintf("status:%s", btm_status_text(res).c_str()));
 
-  btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+  btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
 
   if ((res == BTM_SUCCESS) || (res == BTM_SUCCESS_NO_SECURITY)) {
     acl_set_disconnect_reason(HCI_SUCCESS);
@@ -1202,7 +1378,7 @@ void BTM_ConfirmReqReply(tBTM_STATUS res, const RawAddress& bd_addr) {
 void BTM_PasskeyReqReply(tBTM_STATUS res, const RawAddress& bd_addr,
                          uint32_t passkey) {
   LOG_VERBOSE("BTM_PasskeyReqReply: State: %s  res:%d",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), res);
+              btm_pair_state_descr(btm_sec_cb.pairing_state), res);
 
   if ((btm_sec_cb.pairing_state == BTM_PAIR_STATE_IDLE) ||
       (btm_sec_cb.pairing_bda != bd_addr)) {
@@ -1223,10 +1399,10 @@ void BTM_PasskeyReqReply(tBTM_STATUS res, const RawAddress& bd_addr,
       else
         BTM_SecBondCancel(bd_addr);
 
-      p_dev_rec->sec_rec.sec_flags &=
+      p_dev_rec->sec_flags &=
           ~(BTM_SEC_LINK_KEY_AUTHED | BTM_SEC_LINK_KEY_KNOWN);
 
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       return;
     }
   } else if (btm_sec_cb.pairing_state != BTM_PAIR_STATE_KEY_ENTRY)
@@ -1234,7 +1410,7 @@ void BTM_PasskeyReqReply(tBTM_STATUS res, const RawAddress& bd_addr,
 
   if (passkey > BTM_MAX_PASSKEY_VAL) res = BTM_ILLEGAL_VALUE;
 
-  btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+  btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
 
   if (res != BTM_SUCCESS) {
     /* use BTM_PAIR_STATE_WAIT_AUTH_COMPLETE to report authentication failed
@@ -1272,12 +1448,12 @@ void BTM_ReadLocalOobData(void) { btsnd_hcic_read_local_oob_data(); }
 void BTM_RemoteOobDataReply(tBTM_STATUS res, const RawAddress& bd_addr,
                             const Octet16& c, const Octet16& r) {
   LOG_VERBOSE("State: %s res: %d",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), res);
+              btm_pair_state_descr(btm_sec_cb.pairing_state), res);
 
   /* If timeout already expired or has been canceled, ignore the reply */
   if (btm_sec_cb.pairing_state != BTM_PAIR_STATE_WAIT_LOCAL_OOB_RSP) return;
 
-  btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+  btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
 
   if (res != BTM_SUCCESS) {
     /* use BTM_PAIR_STATE_WAIT_AUTH_COMPLETE to report authentication failed
@@ -1396,22 +1572,20 @@ static bool btm_sec_is_upgrade_possible(tBTM_SEC_DEV_REC* p_dev_rec,
   uint16_t mtm_check = is_originator ? BTM_SEC_OUT_MITM : BTM_SEC_IN_MITM;
   bool is_possible = true;
 
-  if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
+  if (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
     is_possible = false;
     /* Already have a link key to the connected peer. Is the link key secure
      *enough?
      ** Is a link key upgrade even possible?
      */
-    if ((p_dev_rec->sec_rec.security_required & mtm_check) /* needs MITM */
-        &&
-        ((p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB) ||
-         (p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256))
+    if ((p_dev_rec->security_required & mtm_check) /* needs MITM */
+        && ((p_dev_rec->link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB) ||
+            (p_dev_rec->link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256))
         /* has unauthenticated
         link key */
-        && (p_dev_rec->sec_rec.rmt_io_caps <
-            BTM_IO_CAP_MAX) /* a valid peer IO cap */
-        && (btm_sec_io_map[p_dev_rec->sec_rec.rmt_io_caps]
-                          [btm_sec_cb.devcb.loc_io_caps]))
+        && (p_dev_rec->rmt_io_caps < BTM_IO_CAP_MAX) /* a valid peer IO cap */
+        &&
+        (btm_sec_io_map[p_dev_rec->rmt_io_caps][btm_sec_cb.devcb.loc_io_caps]))
     /* authenticated
     link key is possible */
     {
@@ -1423,7 +1597,7 @@ static bool btm_sec_is_upgrade_possible(tBTM_SEC_DEV_REC* p_dev_rec,
     }
   }
   LOG_VERBOSE("is_possible: %d sec_flags: 0x%x", is_possible,
-              p_dev_rec->sec_rec.sec_flags);
+              p_dev_rec->sec_flags);
   return is_possible;
 }
 
@@ -1442,18 +1616,17 @@ static void btm_sec_check_upgrade(tBTM_SEC_DEV_REC* p_dev_rec,
   LOG_VERBOSE("verify whether the link key should be upgraded");
 
   /* Only check if link key already exists */
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN)) return;
+  if (!(p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN)) return;
 
   if (btm_sec_is_upgrade_possible(p_dev_rec, is_originator)) {
-    LOG_VERBOSE("need upgrade!! sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+    LOG_VERBOSE("need upgrade!! sec_flags:0x%x", p_dev_rec->sec_flags);
     /* if the application confirms the upgrade, set the upgrade bit */
     p_dev_rec->sm4 |= BTM_SM4_UPGRADE;
 
     /* Clear the link key known to go through authentication/pairing again */
-    p_dev_rec->sec_rec.sec_flags &=
-        ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED);
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_AUTHENTICATED;
-    LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+    p_dev_rec->sec_flags &= ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED);
+    p_dev_rec->sec_flags &= ~BTM_SEC_AUTHENTICATED;
+    LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_flags);
   }
 }
 
@@ -1499,10 +1672,10 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   /* there are some devices (moto KRZR) which connects to several services at
    * the same time */
   /* we will process one after another */
-  if ((p_dev_rec->sec_rec.p_callback) ||
+  if ((p_dev_rec->p_callback) ||
       (btm_sec_cb.pairing_state != BTM_PAIR_STATE_IDLE)) {
     LOG_DEBUG("security_flags:x%x, sec_flags:x%x", security_required,
-              p_dev_rec->sec_rec.sec_flags);
+              p_dev_rec->sec_flags);
     rc = BTM_CMD_STARTED;
     if ((btm_sec_cb.security_mode == BTM_SEC_MODE_SERVICE) ||
         (BTM_SM4_KNOWN == p_dev_rec->sm4) ||
@@ -1539,7 +1712,7 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
       }
 
       if ((rc == BTM_SUCCESS) && (security_required & BTM_SEC_MODE4_LEVEL4) &&
-          (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+          (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
         rc = BTM_CMD_STARTED;
       }
 
@@ -1560,7 +1733,7 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   }
 
   /* Save the security requirements in case a pairing is needed */
-  p_dev_rec->sec_rec.required_security_flags_for_pairing = security_required;
+  p_dev_rec->required_security_flags_for_pairing = security_required;
 
   /* Modify security_required in btm_sec_l2cap_access_req for Lisbon */
   if (btm_sec_cb.security_mode == BTM_SEC_MODE_SP ||
@@ -1581,8 +1754,7 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
       /* the remote features are not known yet */
       LOG_DEBUG(
           "Remote features have not yet been received sec_flags:0x%02x %s",
-          p_dev_rec->sec_rec.sec_flags,
-          (is_originator) ? "initiator" : "acceptor");
+          p_dev_rec->sec_flags, (is_originator) ? "initiator" : "acceptor");
 
       p_dev_rec->sm4 |= BTM_SM4_REQ_PEND;
       return (BTM_CMD_STARTED);
@@ -1590,23 +1762,23 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   }
 
   LOG_VERBOSE("sm4:0x%x, sec_flags:0x%x, security_required:0x%x chk:%d",
-              p_dev_rec->sm4, p_dev_rec->sec_rec.sec_flags, security_required,
+              p_dev_rec->sm4, p_dev_rec->sec_flags, security_required,
               chk_acp_auth_done);
 
-  p_dev_rec->sec_rec.security_required = security_required;
-  p_dev_rec->sec_rec.p_ref_data = p_ref_data;
+  p_dev_rec->security_required = security_required;
+  p_dev_rec->p_ref_data = p_ref_data;
   p_dev_rec->is_originator = is_originator;
 
   if (chk_acp_auth_done) {
     LOG_VERBOSE(
         "(SM4 to SM4) btm_sec_l2cap_access_req rspd. authenticated: x%x, enc: "
         "x%x",
-        (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED),
-        (p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED));
+        (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED),
+        (p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED));
     /* SM4, but we do not know for sure which level of security we need.
      * as long as we have a link key, it's OK */
-    if ((0 == (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) ||
-        (0 == (p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED))) {
+    if ((0 == (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) ||
+        (0 == (p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED))) {
       rc = BTM_DELAY_CHECK;
       /*
       2046 may report HCI_Encryption_Change and L2C Connection Request out of
@@ -1615,28 +1787,28 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
       */
       LOG_INFO(
           "peer should have initiated security process by now (SM4 to SM4)");
-      p_dev_rec->sec_rec.p_callback = p_callback;
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_DELAY_FOR_ENC;
+      p_dev_rec->p_callback = p_callback;
+      p_dev_rec->sec_state = BTM_SEC_STATE_DELAY_FOR_ENC;
       (*p_callback)(&bd_addr, transport, p_ref_data, rc);
 
       return BTM_SUCCESS;
     }
   }
 
-  p_dev_rec->sec_rec.p_callback = p_callback;
+  p_dev_rec->p_callback = p_callback;
 
   if (BTM_SEC_IS_SM4(p_dev_rec->sm4)) {
-    if ((p_dev_rec->sec_rec.security_required & BTM_SEC_MODE4_LEVEL4) &&
-        (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+    if ((p_dev_rec->security_required & BTM_SEC_MODE4_LEVEL4) &&
+        (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
       /* BTM_LKEY_TYPE_AUTH_COMB_P_256 is the only acceptable key in this case
        */
-      if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
+      if ((p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
         p_dev_rec->sm4 |= BTM_SM4_UPGRADE;
       }
-      p_dev_rec->sec_rec.sec_flags &=
+      p_dev_rec->sec_flags &=
           ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED |
             BTM_SEC_AUTHENTICATED);
-      LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+      LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_flags);
     } else {
       /* If we already have a link key to the connected peer, is it secure
        * enough? */
@@ -1647,9 +1819,9 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   rc = btm_sec_execute_procedure(p_dev_rec);
   if (rc != BTM_CMD_STARTED) {
     LOG_VERBOSE("p_dev_rec=%p, clearing callback. old p_callback=%p", p_dev_rec,
-                p_dev_rec->sec_rec.p_callback);
-    p_dev_rec->sec_rec.p_callback = NULL;
-    (*p_callback)(&bd_addr, transport, p_dev_rec->sec_rec.p_ref_data, rc);
+                p_dev_rec->p_callback);
+    p_dev_rec->p_callback = NULL;
+    (*p_callback)(&bd_addr, transport, p_dev_rec->p_ref_data, rc);
   }
 
   return (rc);
@@ -1752,10 +1924,10 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
   /* there are some devices (moto phone) which connects to several services at
    * the same time */
   /* we will process one after another */
-  if ((p_dev_rec->sec_rec.p_callback) ||
+  if ((p_dev_rec->p_callback) ||
       (btm_sec_cb.pairing_state != BTM_PAIR_STATE_IDLE)) {
     LOG_DEBUG("Pairing in progress pairing_state:%s",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state));
+              btm_pair_state_descr(btm_sec_cb.pairing_state));
 
     rc = BTM_CMD_STARTED;
 
@@ -1793,13 +1965,13 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
         }
       }
       if ((rc == BTM_SUCCESS) && (security_required & BTM_SEC_MODE4_LEVEL4) &&
-          (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+          (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
         rc = BTM_CMD_STARTED;
       }
     }
 
     /* the new security request */
-    if (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_IDLE) {
+    if (p_dev_rec->sec_state != BTM_SEC_STATE_IDLE) {
       LOG_DEBUG("A pending security procedure in progress");
       rc = BTM_CMD_STARTED;
     }
@@ -1848,24 +2020,24 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
     security_required |= BTM_SEC_IN_MITM;
   }
 
-  p_dev_rec->sec_rec.required_security_flags_for_pairing = security_required;
-  p_dev_rec->sec_rec.security_required = security_required;
+  p_dev_rec->required_security_flags_for_pairing = security_required;
+  p_dev_rec->security_required = security_required;
 
   if (btm_sec_cb.security_mode == BTM_SEC_MODE_SP ||
       btm_sec_cb.security_mode == BTM_SEC_MODE_SC) {
     if (BTM_SEC_IS_SM4(p_dev_rec->sm4)) {
-      if ((p_dev_rec->sec_rec.security_required & BTM_SEC_MODE4_LEVEL4) &&
-          (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+      if ((p_dev_rec->security_required & BTM_SEC_MODE4_LEVEL4) &&
+          (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
         /* BTM_LKEY_TYPE_AUTH_COMB_P_256 is the only acceptable key in this case
          */
-        if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
+        if ((p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
           p_dev_rec->sm4 |= BTM_SM4_UPGRADE;
         }
 
-        p_dev_rec->sec_rec.sec_flags &=
+        p_dev_rec->sec_flags &=
             ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED |
               BTM_SEC_AUTHENTICATED);
-        LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+        LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_flags);
       } else {
         LOG_DEBUG("Already have link key; checking if link key is sufficient");
         btm_sec_check_upgrade(p_dev_rec, is_originator);
@@ -1874,8 +2046,8 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
   }
 
   p_dev_rec->is_originator = is_originator;
-  p_dev_rec->sec_rec.p_callback = p_callback;
-  p_dev_rec->sec_rec.p_ref_data = p_ref_data;
+  p_dev_rec->p_callback = p_callback;
+  p_dev_rec->p_ref_data = p_ref_data;
 
   rc = btm_sec_execute_procedure(p_dev_rec);
   LOG_DEBUG("Started security procedure peer:%s btm_status:%s",
@@ -1883,7 +2055,7 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
             btm_status_text(rc).c_str());
   if (rc != BTM_CMD_STARTED) {
     if (p_callback) {
-      p_dev_rec->sec_rec.p_callback = NULL;
+      p_dev_rec->p_callback = NULL;
       (*p_callback)(&bd_addr, transport, p_ref_data, rc);
     }
   }
@@ -1952,8 +2124,8 @@ static void btm_sec_bond_cancel_complete(void) {
      * this function also needs to do proper clean up.
      */
     p_dev_rec = btm_find_dev(btm_sec_cb.pairing_bda);
-    if (p_dev_rec != NULL) p_dev_rec->sec_rec.security_required = BTM_SEC_NONE;
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+    if (p_dev_rec != NULL) p_dev_rec->security_required = BTM_SEC_NONE;
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
     /* Notify application that the cancel succeeded */
     if (btm_sec_cb.api.p_bond_cancel_cmpl_callback)
@@ -1974,8 +2146,7 @@ static void btm_sec_bond_cancel_complete(void) {
  ******************************************************************************/
 void btm_create_conn_cancel_complete(uint8_t status, const RawAddress bd_addr) {
   LOG_VERBOSE("btm_create_conn_cancel_complete(): in State: %s  status:%d",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
-              status);
+              btm_pair_state_descr(btm_sec_cb.pairing_state), status);
   log_link_layer_connection_event(
       &bd_addr, bluetooth::common::kUnknownConnectionHandle,
       android::bluetooth::DIRECTION_OUTGOING, android::bluetooth::LINK_TYPE_ACL,
@@ -2087,15 +2258,15 @@ void btm_sec_abort_access_req(const RawAddress& bd_addr) {
 
   if (!p_dev_rec) return;
 
-  if ((p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_AUTHORIZING) &&
-      (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_AUTHENTICATING))
+  if ((p_dev_rec->sec_state != BTM_SEC_STATE_AUTHORIZING) &&
+      (p_dev_rec->sec_state != BTM_SEC_STATE_AUTHENTICATING))
     return;
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
   LOG_VERBOSE("clearing callback. p_dev_rec=%p, p_callback=%p", p_dev_rec,
-              p_dev_rec->sec_rec.p_callback);
-  p_dev_rec->sec_rec.p_callback = NULL;
+              p_dev_rec->p_callback);
+  p_dev_rec->p_callback = NULL;
 }
 
 /*******************************************************************************
@@ -2117,7 +2288,7 @@ static tBTM_STATUS btm_sec_dd_create_conn(tBTM_SEC_DEV_REC* p_dev_rec) {
     if (BTM_IsAclConnectionUp(p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR)) {
       return BTM_SUCCESS;
     }
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
     return BTM_CMD_STARTED;
   } else if (status == BTM_NO_RESOURCES) {
     return BTM_NO_RESOURCES;
@@ -2129,7 +2300,7 @@ static tBTM_STATUS btm_sec_dd_create_conn(tBTM_SEC_DEV_REC* p_dev_rec) {
   LOG_INFO("Security Manager: %s",
            ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr));
 
-  btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
+  btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
 
   return (BTM_CMD_STARTED);
 }
@@ -2209,41 +2380,41 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
     LOG_DEBUG(
         "Remote read request complete for unknown device pairing_state:%s "
         "status:%s name:%s",
-        tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
+        btm_pair_state_descr(btm_sec_cb.pairing_state),
         hci_status_code_text(status).c_str(), p_bd_name);
 
     call_registered_rmt_name_callbacks(p_bd_addr, nullptr, nullptr, status);
     return;
   }
 
-  old_sec_state = p_dev_rec->sec_rec.sec_state;
+  old_sec_state = p_dev_rec->sec_state;
   if (status == HCI_SUCCESS) {
     LOG_DEBUG(
         "Remote read request complete for known device pairing_state:%s "
         "name:%s sec_state:%s",
-        tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), p_bd_name,
-        security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+        btm_pair_state_descr(btm_sec_cb.pairing_state), p_bd_name,
+        security_state_text(p_dev_rec->sec_state).c_str());
 
     strlcpy((char*)p_dev_rec->sec_bd_name, (const char*)p_bd_name,
             BTM_MAX_REM_BD_NAME_LEN + 1);
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_NAME_KNOWN;
+    p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
     LOG_VERBOSE("setting BTM_SEC_NAME_KNOWN sec_flags:0x%x",
-                p_dev_rec->sec_rec.sec_flags);
+                p_dev_rec->sec_flags);
   } else {
     LOG_WARN(
         "Remote read request failed for known device pairing_state:%s "
         "status:%s name:%s sec_state:%s",
-        tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
+        btm_pair_state_descr(btm_sec_cb.pairing_state),
         hci_status_code_text(status).c_str(), p_bd_name,
-        security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+        security_state_text(p_dev_rec->sec_state).c_str());
 
     /* Notify all clients waiting for name to be resolved even if it failed so
      * clients can continue */
     p_dev_rec->sec_bd_name[0] = 0;
   }
 
-  if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_GETTING_NAME)
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  if (p_dev_rec->sec_state == BTM_SEC_STATE_GETTING_NAME)
+    p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
   /* Notify all clients waiting for name to be resolved */
   call_registered_rmt_name_callbacks(p_bd_addr, p_dev_rec->dev_class,
@@ -2264,12 +2435,12 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
       btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
       (*btm_sec_cb.api.p_pin_callback)(
           p_dev_rec->bd_addr, p_dev_rec->dev_class, p_bd_name,
-          (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+          (p_dev_rec->required_security_flags_for_pairing &
            BTM_SEC_IN_MIN_16_DIGIT_PIN));
     }
 
     /* Set the same state again to force the timer to be restarted */
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_PIN);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_PIN);
     return;
   }
 
@@ -2284,7 +2455,7 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
       }
 
       if (status != HCI_SUCCESS) {
-        btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+        btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
         return NotifyBondingChange(*p_dev_rec, status);
       }
@@ -2328,7 +2499,7 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
           } else if (req_status != BTM_CMD_STARTED) {
             LOG_WARN("failed to start connection");
 
-            btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+            btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
             NotifyBondingChange(*p_dev_rec, HCI_ERR_MEMORY_FULL);
           }
@@ -2352,19 +2523,19 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
 
   /* check if we were delaying link_key_callback because name was not resolved
    */
-  if (p_dev_rec->sec_rec.link_key_not_sent) {
+  if (p_dev_rec->link_key_not_sent) {
     /* If HCI connection complete has not arrived, wait for it */
     if (p_dev_rec->hci_handle == HCI_INVALID_HANDLE) return;
 
-    p_dev_rec->sec_rec.link_key_not_sent = false;
+    p_dev_rec->link_key_not_sent = false;
     btm_send_link_key_notif(p_dev_rec);
   }
 
   /* If this is a bonding procedure can disconnect the link now */
   if ((btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
-      (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) {
+      (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) {
     LOG_WARN("btm_sec_rmt_name_request_complete (none/ce)");
-    p_dev_rec->sec_rec.security_required &= ~(BTM_SEC_OUT_AUTHENTICATE);
+    p_dev_rec->security_required &= ~(BTM_SEC_OUT_AUTHENTICATE);
     l2cu_start_post_bond_timer(p_dev_rec->hci_handle);
     return;
   }
@@ -2470,7 +2641,7 @@ void btm_io_capabilities_req(RawAddress p) {
   p_dev_rec->sm4 |= BTM_SM4_TRUE;
 
   LOG_VERBOSE("State: %s, Security Mode: %d, Device security Flags: 0x%04x",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
+              btm_pair_state_descr(btm_sec_cb.pairing_state),
               btm_sec_cb.security_mode, btm_sec_cb.pairing_flags);
 
   uint8_t err_code = 0;
@@ -2479,7 +2650,7 @@ void btm_io_capabilities_req(RawAddress p) {
     /* initiator connecting */
     case BTM_PAIR_STATE_IDLE:
       // TODO: Handle Idle pairing state
-      // security_required = p_dev_rec->sec_rec.security_required;
+      // security_required = p_dev_rec->security_required;
       break;
 
     /* received IO capability response already->acceptor */
@@ -2539,15 +2710,14 @@ void btm_io_capabilities_req(RawAddress p) {
     /* local device initiated the pairing non-bonding -> use
      * required_security_flags_for_pairing */
     if (!(btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
-        (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+        (p_dev_rec->required_security_flags_for_pairing &
          BTM_SEC_OUT_AUTHENTICATE)) {
       if (btm_sec_cb.security_mode == BTM_SEC_MODE_SC) {
         /* SC only mode device requires MITM protection */
         evt_data.auth_req = BTM_AUTH_SP_YES;
       } else {
         evt_data.auth_req =
-            (p_dev_rec->sec_rec.required_security_flags_for_pairing &
-             BTM_SEC_OUT_MITM)
+            (p_dev_rec->required_security_flags_for_pairing & BTM_SEC_OUT_MITM)
                 ? BTM_AUTH_SP_YES
                 : BTM_AUTH_SP_NO;
       }
@@ -2562,7 +2732,7 @@ void btm_io_capabilities_req(RawAddress p) {
   if (evt_data.bd_addr == btm_sec_cb.connecting_bda)
     memcpy(p_dev_rec->dev_class, btm_sec_cb.connecting_dc, DEV_CLASS_LEN);
 
-  btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_IOCAPS);
+  btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_IOCAPS);
 
   if (p_dev_rec->sm4 & BTM_SM4_UPGRADE) {
     p_dev_rec->sm4 &= ~BTM_SM4_UPGRADE;
@@ -2597,8 +2767,8 @@ void btm_io_capabilities_req(RawAddress p) {
   btm_sec_cb.devcb.loc_io_caps = evt_data.io_cap;
 
   LOG_VERBOSE("State: %s  IO_CAP:%d oob_data:%d auth_req:%d",
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
-              evt_data.io_cap, evt_data.oob_data, evt_data.auth_req);
+              btm_pair_state_descr(btm_sec_cb.pairing_state), evt_data.io_cap,
+              evt_data.oob_data, evt_data.auth_req);
 
   btsnd_hcic_io_cap_req_reply(evt_data.bd_addr, evt_data.io_cap,
                               evt_data.oob_data, evt_data.auth_req);
@@ -2624,7 +2794,7 @@ void btm_io_capabilities_rsp(const tBTM_SP_IO_RSP evt_data) {
   if (btm_sec_cb.pairing_state == BTM_PAIR_STATE_IDLE) {
     btm_sec_cb.pairing_bda = evt_data.bd_addr;
 
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_INCOMING_SSP);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_INCOMING_SSP);
 
     /* work around for FW bug */
     btm_inq_stop_on_ssp();
@@ -2649,8 +2819,8 @@ void btm_io_capabilities_rsp(const tBTM_SP_IO_RSP evt_data) {
   }
 
   /* save the IO capability in the device record */
-  p_dev_rec->sec_rec.rmt_io_caps = evt_data.io_cap;
-  p_dev_rec->sec_rec.rmt_auth_req = evt_data.auth_req;
+  p_dev_rec->rmt_io_caps = evt_data.io_cap;
+  p_dev_rec->rmt_auth_req = evt_data.auth_req;
 
   if (btm_sec_cb.api.p_sp_callback)
     (*btm_sec_cb.api.p_sp_callback)(BTM_SP_IO_RSP_EVT,
@@ -2679,7 +2849,7 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
   p_bda = bda;
   LOG_VERBOSE("BDA: %s, event: 0x%x, state: %s",
               ADDRESS_TO_LOGGABLE_CSTR(p_bda), event,
-              tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state));
+              btm_pair_state_descr(btm_sec_cb.pairing_state));
 
   p_dev_rec = btm_find_dev(p_bda);
   if ((p_dev_rec != NULL) &&
@@ -2694,7 +2864,7 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
     switch (event) {
       case BTM_SP_CFM_REQ_EVT:
         /* Numeric confirmation. Need user to conf the passkey */
-        btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_NUMERIC_CONFIRM);
+        btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_NUMERIC_CONFIRM);
 
         /* The device record must be allocated in the "IO cap exchange" step */
         evt_data.cfm_req.num_val = value;
@@ -2705,7 +2875,7 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
 
         /* process user confirm req in association with the auth_req param */
         if (btm_sec_cb.devcb.loc_io_caps == BTM_IO_CAP_IO) {
-          if (p_dev_rec->sec_rec.rmt_io_caps == BTM_IO_CAP_UNKNOWN) {
+          if (p_dev_rec->rmt_io_caps == BTM_IO_CAP_UNKNOWN) {
             LOG_ERROR(
                 "did not receive IO cap response prior"
                 " to BTM_SP_CFM_REQ_EVT, failing pairing request");
@@ -2714,10 +2884,10 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
             return;
           }
 
-          if ((p_dev_rec->sec_rec.rmt_io_caps == BTM_IO_CAP_IO ||
-               p_dev_rec->sec_rec.rmt_io_caps == BTM_IO_CAP_OUT) &&
+          if ((p_dev_rec->rmt_io_caps == BTM_IO_CAP_IO ||
+               p_dev_rec->rmt_io_caps == BTM_IO_CAP_OUT) &&
               (btm_sec_cb.devcb.loc_io_caps == BTM_IO_CAP_IO) &&
-              ((p_dev_rec->sec_rec.rmt_auth_req & BTM_AUTH_SP_YES) ||
+              ((p_dev_rec->rmt_auth_req & BTM_AUTH_SP_YES) ||
                (btm_sec_cb.devcb.loc_auth_req & BTM_AUTH_SP_YES))) {
             /* Use Numeric Comparison if
              * 1. Local IO capability is DisplayYesNo,
@@ -2731,13 +2901,13 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
             "btm_proc_sp_req_evt()  just_works:%d, io loc:%d, rmt:%d, auth "
             "loc:%d, rmt:%d",
             evt_data.cfm_req.just_works, btm_sec_cb.devcb.loc_io_caps,
-            p_dev_rec->sec_rec.rmt_io_caps, btm_sec_cb.devcb.loc_auth_req,
-            p_dev_rec->sec_rec.rmt_auth_req);
+            p_dev_rec->rmt_io_caps, btm_sec_cb.devcb.loc_auth_req,
+            p_dev_rec->rmt_auth_req);
 
         evt_data.cfm_req.loc_auth_req = btm_sec_cb.devcb.loc_auth_req;
-        evt_data.cfm_req.rmt_auth_req = p_dev_rec->sec_rec.rmt_auth_req;
+        evt_data.cfm_req.rmt_auth_req = p_dev_rec->rmt_auth_req;
         evt_data.cfm_req.loc_io_caps = btm_sec_cb.devcb.loc_io_caps;
-        evt_data.cfm_req.rmt_io_caps = p_dev_rec->sec_rec.rmt_io_caps;
+        evt_data.cfm_req.rmt_io_caps = p_dev_rec->rmt_io_caps;
         break;
 
       case BTM_SP_KEY_NOTIF_EVT:
@@ -2746,13 +2916,13 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
         LOG_VERBOSE("BTM_SP_KEY_NOTIF_EVT:  passkey: %u",
                     evt_data.key_notif.passkey);
 
-        btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+        btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
         break;
 
       case BTM_SP_KEY_REQ_EVT:
         if (btm_sec_cb.devcb.loc_io_caps != BTM_IO_CAP_NONE) {
           /* HCI_USER_PASSKEY_REQUEST_EVT */
-          btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_KEY_ENTRY);
+          btm_sec_change_pairing_state(BTM_PAIR_STATE_KEY_ENTRY);
         }
         break;
     }
@@ -2825,14 +2995,14 @@ void btm_simple_pair_complete(const RawAddress bd_addr, uint8_t status) {
 
   LOG_VERBOSE(
       "btm_simple_pair_complete()  Pair State: %s  Status:%d  sec_state: %u",
-      tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), status,
-      p_dev_rec->sec_rec.sec_state);
+      btm_pair_state_descr(btm_sec_cb.pairing_state), status,
+      p_dev_rec->sec_state);
 
   if (status == HCI_SUCCESS) {
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_AUTHENTICATED;
+    p_dev_rec->sec_flags |= BTM_SEC_AUTHENTICATED;
   } else if (status == HCI_ERR_PAIRING_NOT_ALLOWED) {
     /* The test spec wants the peer device to get this failure code. */
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_DISCONNECT);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_DISCONNECT);
 
     /* Change the timer to 1 second */
     alarm_set_on_mloop(btm_sec_cb.pairing_timer, BT_1SEC_TIMEOUT_MS,
@@ -2841,7 +3011,7 @@ void btm_simple_pair_complete(const RawAddress bd_addr, uint8_t status) {
     /* stop the timer */
     alarm_cancel(btm_sec_cb.pairing_timer);
 
-    if (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_AUTHENTICATING) {
+    if (p_dev_rec->sec_state != BTM_SEC_STATE_AUTHENTICATING) {
       /* the initiating side: will receive auth complete event. disconnect ACL
        * at that time */
       disc = true;
@@ -2889,7 +3059,7 @@ void btm_rem_oob_req(const RawAddress bd_addr) {
     strlcpy((char*)evt_data.bd_name, (char*)p_dev_rec->sec_bd_name,
             BTM_MAX_REM_BD_NAME_LEN + 1);
 
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_OOB_RSP);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_OOB_RSP);
     if ((*btm_sec_cb.api.p_sp_callback)(BTM_SP_RMT_OOB_EVT,
                                         (tBTM_SP_EVT_DATA*)&evt_data) ==
         BTM_NOT_AUTHORIZED) {
@@ -2951,11 +3121,11 @@ static void btm_sec_auth_collision(uint16_t handle) {
 
     if (p_dev_rec != NULL) {
       LOG_VERBOSE("btm_sec_auth_collision: state %d (retrying in a moment...)",
-                  p_dev_rec->sec_rec.sec_state);
+                  p_dev_rec->sec_state);
       /* We will restart authentication after timeout */
-      if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING ||
-          p_dev_rec->sec_rec.is_security_state_bredr_encrypting())
-        p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+      if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING ||
+          p_dev_rec->is_security_state_bredr_encrypting())
+        p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
       btm_sec_cb.p_collided_dev_rec = p_dev_rec;
       alarm_set_on_mloop(btm_sec_cb.sec_collision_timer, BT_1SEC_TIMEOUT_MS,
@@ -2992,15 +3162,15 @@ static bool btm_sec_auth_retry(uint16_t handle, uint8_t status) {
     btm_sec_cb.collision_start_time = 0;
     btm_restore_mode();
     p_dev_rec->sm4 |= BTM_SM4_RETRY;
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
+    p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
     LOG_VERBOSE("Retry for missing key sm4:x%x sec_flags:0x%x", p_dev_rec->sm4,
-                p_dev_rec->sec_rec.sec_flags);
+                p_dev_rec->sec_flags);
 
     /* With BRCM controller, we do not need to delete the stored link key in
        controller.
        If the stack may sit on top of other controller, we may need this
        BTM_DeleteStoredLinkKey (bd_addr, NULL); */
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+    p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
     btm_sec_execute_procedure(p_dev_rec);
     return true;
   }
@@ -3017,14 +3187,13 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
   if (p_dev_rec) {
     LOG_VERBOSE(
         "Security Manager: in state: %s, handle: %d, status: %d, "
-        "dev->sec_rec.sec_state:%d, bda: %s, RName: %s",
-        tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), handle,
-        status, p_dev_rec->sec_rec.sec_state,
-        ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr), p_dev_rec->sec_bd_name);
+        "dev->sec_state:%d, bda: %s, RName: %s",
+        btm_pair_state_descr(btm_sec_cb.pairing_state), handle, status,
+        p_dev_rec->sec_state, ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr),
+        p_dev_rec->sec_bd_name);
   } else {
     LOG_VERBOSE("Security Manager: in state: %s, handle: %d, status: %d",
-                tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
-                handle, status);
+                btm_pair_state_descr(btm_sec_cb.pairing_state), handle, status);
   }
 
   /* For transaction collision we need to wait and repeat.  There is no need */
@@ -3046,15 +3215,15 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
   */
   if (p_dev_rec && (btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
       !(btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)) {
-    p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+    p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
 
     l2cu_start_post_bond_timer(p_dev_rec->hci_handle);
   }
 
   if (!p_dev_rec) return;
 
-  if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+    p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
     was_authenticating = true;
     /* There can be a race condition, when we are starting authentication
      * and the peer device is doing encryption.
@@ -3064,13 +3233,12 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
      * encrypted link, so device is correct.
      */
     if ((status == HCI_ERR_COMMAND_DISALLOWED) &&
-        ((p_dev_rec->sec_rec.sec_flags &
-          (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED)) ==
+        ((p_dev_rec->sec_flags & (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED)) ==
          (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED))) {
       status = HCI_SUCCESS;
     }
     if (status == HCI_SUCCESS) {
-      p_dev_rec->sec_rec.sec_flags |= BTM_SEC_AUTHENTICATED;
+      p_dev_rec->sec_flags |= BTM_SEC_AUTHENTICATED;
     }
   }
 
@@ -3079,7 +3247,7 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
     if (btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) {
       are_bonding = true;
     }
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
   }
 
   if (was_authenticating == false) {
@@ -3101,7 +3269,7 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
 
   /* If this is a bonding procedure can disconnect the link now */
   if (are_bonding) {
-    p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+    p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
 
     if (status != HCI_SUCCESS) {
       if (((status != HCI_ERR_PEER_USER) &&
@@ -3146,12 +3314,12 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
     return;
   }
 
-  if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+  if (p_dev_rec->pin_code_length >= 16 ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
     // If we have MITM protection we have a higher level of security than
     // provided by 16 digits PIN
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+    p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
   }
 
   /* Authentication succeeded, execute the next security procedure, if any */
@@ -3203,23 +3371,22 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
       " request:%s state:%s sec_flags:0x%x",
       hci_status_code_text(status).c_str(),
       (encr_enable) ? "encrypt" : "unencrypt",
-      (p_dev_rec->sec_rec.sec_state) ? "encrypted" : "unencrypted",
-      p_dev_rec->sec_rec.sec_flags);
+      (p_dev_rec->sec_state) ? "encrypted" : "unencrypted",
+      p_dev_rec->sec_flags);
 
   if (status == HCI_SUCCESS) {
     if (encr_enable) {
       if (p_dev_rec->hci_handle == handle) {  // classic
-        p_dev_rec->sec_rec.sec_flags |=
-            (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED);
-        if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-            p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-            p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
-          p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+        p_dev_rec->sec_flags |= (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED);
+        if (p_dev_rec->pin_code_length >= 16 ||
+            p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+            p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+          p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
         }
       } else if (p_dev_rec->ble_hci_handle == handle) {  // BLE
-        p_dev_rec->sec_rec.set_le_device_encrypted();
-        if (p_dev_rec->sec_rec.is_le_link_key_authenticated()) {
-          p_dev_rec->sec_rec.set_le_device_authenticated();
+        p_dev_rec->set_le_device_encrypted();
+        if (p_dev_rec->is_le_link_key_authenticated()) {
+            p_dev_rec->set_le_device_authenticated();
         }
       } else {
         LOG_ERROR(
@@ -3233,9 +3400,9 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
       /* mark link not to be encrypted, so that when we execute security next
        * time it will kick in again */
       if (p_dev_rec->hci_handle == handle) {  // clasic
-        p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_ENCRYPTED;
+        p_dev_rec->sec_flags &= ~BTM_SEC_ENCRYPTED;
       } else if (p_dev_rec->ble_hci_handle == handle) {  // BLE
-        p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_ENCRYPTED;
+        p_dev_rec->sec_flags &= ~BTM_SEC_LE_ENCRYPTED;
       } else {
         LOG_ERROR(
             "Received encryption change for unknown device handle:0x%04x "
@@ -3245,8 +3412,8 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
     }
   }
 
-  const bool is_encrypted = p_dev_rec->sec_rec.is_le_device_encrypted() ||
-                            p_dev_rec->sec_rec.is_device_encrypted();
+  const bool is_encrypted =
+      p_dev_rec->is_le_device_encrypted() || p_dev_rec->is_device_encrypted();
   BTM_LogHistory(
       kBtmLogTag,
       (transport == BT_TRANSPORT_LE) ? p_dev_rec->ble.pseudo_addr
@@ -3257,49 +3424,47 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
                          bt_transport_text(transport).c_str(),
                          is_encrypted ? 'T' : 'F'));
 
-  LOG_DEBUG("after update p_dev_rec->sec_rec.sec_flags=0x%x",
-            p_dev_rec->sec_rec.sec_flags);
+  LOG_DEBUG("after update p_dev_rec->sec_flags=0x%x", p_dev_rec->sec_flags);
 
   btm_sec_check_pending_enc_req(p_dev_rec, transport, encr_enable);
 
   if (transport == BT_TRANSPORT_LE) {
     if (status == HCI_ERR_KEY_MISSING || status == HCI_ERR_AUTH_FAILURE ||
         status == HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE) {
-      p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
-      p_dev_rec->sec_rec.ble_keys.key_type = BTM_LE_KEY_NONE;
+      p_dev_rec->sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
+      p_dev_rec->ble_keys.key_type = BTM_LE_KEY_NONE;
     }
-    p_dev_rec->sec_rec.sec_status = status;
+    p_dev_rec->sec_status = status;
     btm_ble_link_encrypted(p_dev_rec->ble.pseudo_addr, encr_enable);
     return;
   } else {
     /* BR/EDR connection, update the encryption key size to be 16 as always */
-    p_dev_rec->sec_rec.enc_key_size = 16;
+    p_dev_rec->enc_key_size = 16;
   }
 
-  LOG_DEBUG("in new_encr_key_256 is %d",
-            p_dev_rec->sec_rec.new_encryption_key_is_p256);
+  LOG_DEBUG("in new_encr_key_256 is %d", p_dev_rec->new_encryption_key_is_p256);
 
   if ((status == HCI_SUCCESS) && encr_enable &&
       (p_dev_rec->hci_handle == handle)) {
     /* if BR key is temporary no need for LE LTK derivation */
     bool derive_ltk = true;
-    if (p_dev_rec->sec_rec.rmt_auth_req == BTM_AUTH_SP_NO &&
+    if (p_dev_rec->rmt_auth_req == BTM_AUTH_SP_NO &&
         btm_sec_cb.devcb.loc_auth_req == BTM_AUTH_SP_NO) {
       derive_ltk = false;
       LOG_VERBOSE("BR key is temporary, skip derivation of LE LTK");
     }
     tHCI_ROLE role = HCI_ROLE_UNKNOWN;
     BTM_GetRole(p_dev_rec->bd_addr, &role);
-    if (p_dev_rec->sec_rec.new_encryption_key_is_p256) {
+    if (p_dev_rec->new_encryption_key_is_p256) {
       if (btm_sec_use_smp_br_chnl(p_dev_rec) && role == HCI_ROLE_CENTRAL &&
           /* if LE key is not known, do deriving */
-          (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) ||
+          (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) ||
            /* or BR key is higher security than existing LE keys */
-           (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
-            (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_AUTHED))) &&
+           (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
+            (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_AUTHED))) &&
           derive_ltk) {
         /* BR/EDR is encrypted with LK that can be used to derive LE LTK */
-        p_dev_rec->sec_rec.new_encryption_key_is_p256 = false;
+        p_dev_rec->new_encryption_key_is_p256 = false;
 
         LOG_VERBOSE("start SM over BR/EDR");
         SMP_BR_PairWith(p_dev_rec->bd_addr);
@@ -3308,17 +3473,17 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
   }
 
   /* If this encryption was started by peer do not need to do anything */
-  if (!p_dev_rec->sec_rec.is_security_state_bredr_encrypting()) {
-    if (BTM_SEC_STATE_DELAY_FOR_ENC == p_dev_rec->sec_rec.sec_state) {
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  if (!p_dev_rec->is_security_state_bredr_encrypting()) {
+    if (BTM_SEC_STATE_DELAY_FOR_ENC == p_dev_rec->sec_state) {
+      p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
       LOG_VERBOSE("clearing callback. p_dev_rec=%p, p_callback=%p", p_dev_rec,
-                  p_dev_rec->sec_rec.p_callback);
-      p_dev_rec->sec_rec.p_callback = NULL;
+                  p_dev_rec->p_callback);
+      p_dev_rec->p_callback = NULL;
       l2cu_resubmit_pending_sec_req(&p_dev_rec->bd_addr);
       return;
     } else if (!concurrentPeerAuthIsEnabled() &&
-               p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+               p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+      p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
       return;
     }
     if (!handleUnexpectedEncryptionChange()) {
@@ -3326,7 +3491,7 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
     }
   }
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
   /* If encryption setup failed, notify the waiting layer */
   if (status != HCI_SUCCESS) {
     btm_sec_dev_rec_cback_event(p_dev_rec, BTM_ERR_PROCESSING, false);
@@ -3362,7 +3527,7 @@ static void btm_sec_connect_after_reject_timeout(void* /* data */) {
   if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED) {
     LOG_WARN("Security Manager: failed to start connection");
 
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
     NotifyBondingChange(*p_dev_rec, HCI_ERR_MEMORY_FULL);
   }
@@ -3391,7 +3556,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
     LOG_DEBUG(
         "Connected to new device state:%s handle:0x%04x status:%s "
         "enc_mode:%hhu bda:%s",
-        tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), handle,
+        btm_pair_state_descr(btm_sec_cb.pairing_state), handle,
         hci_status_code_text(status).c_str(), enc_mode,
         ADDRESS_TO_LOGGABLE_CSTR(bda));
 
@@ -3406,7 +3571,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
           btm_sec_cb.pairing_bda == bda) {
         LOG_WARN("Connection failed during bonding attempt peer:%s reason:%s",
                  ADDRESS_TO_LOGGABLE_CSTR(bda), hci_error_code_text(status).c_str());
-        btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+        btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       }
 
       LOG_DEBUG("Ignoring failed device connection peer:%s reason:%s",
@@ -3417,7 +3582,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
     LOG_DEBUG(
         "Connected to known device state:%s handle:0x%04x status:%s "
         "enc_mode:%hhu bda:%s RName:%s",
-        tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state), handle,
+        btm_pair_state_descr(btm_sec_cb.pairing_state), handle,
         hci_status_code_text(status).c_str(), enc_mode,
         ADDRESS_TO_LOGGABLE_CSTR(bda), p_dev_rec->sec_bd_name);
 
@@ -3439,7 +3604,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
               "without asking PIN");
 
           p_dev_rec->sm4 &= ~BTM_SM4_CONN_PEND;
-          if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) {
+          if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) {
             /* remote device name is known, start a new acl connection */
 
             /* Start timer with 0 to initiate connection with new LCB */
@@ -3450,12 +3615,12 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
           } else {
             /* remote device name is unknowm, start getting remote name first */
 
-            btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_GET_REM_NAME);
+            btm_sec_change_pairing_state(BTM_PAIR_STATE_GET_REM_NAME);
             if (BTM_ReadRemoteDeviceName(p_dev_rec->bd_addr, NULL,
                                          BT_TRANSPORT_BR_EDR) !=
                 BTM_CMD_STARTED) {
               LOG_ERROR("cannot read remote name");
-              btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+              btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
             }
           }
           return;
@@ -3485,11 +3650,11 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
       btm_sec_cb.pairing_flags &= ~BTM_PAIR_FLAGS_REJECTED_CONNECT;
       if (BTM_SEC_IS_SM4_UNKNOWN(p_dev_rec->sm4)) {
         /* Try again: RNR when no ACL causes HCI_RMT_HOST_SUP_FEAT_NOTIFY_EVT */
-        btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_GET_REM_NAME);
+        btm_sec_change_pairing_state(BTM_PAIR_STATE_GET_REM_NAME);
         if (BTM_ReadRemoteDeviceName(bda, NULL, BT_TRANSPORT_BR_EDR) !=
             BTM_CMD_STARTED) {
           LOG_ERROR("cannot read remote name");
-          btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+          btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
         }
         return;
       }
@@ -3522,13 +3687,12 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
   if (status != HCI_SUCCESS) {
     /* If connection failed because of during pairing, need to tell user */
     if (is_pairing_device) {
-      p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
-      p_dev_rec->sec_rec.sec_flags &=
+      p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+      p_dev_rec->sec_flags &=
           ~((BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED) << bit_shift);
-      LOG_VERBOSE("security_required:%x ",
-                  p_dev_rec->sec_rec.security_required);
+      LOG_VERBOSE("security_required:%x ", p_dev_rec->security_required);
 
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
       /* We need to notify host that the key is not known any more */
       NotifyBondingChange(*p_dev_rec, status);
@@ -3539,7 +3703,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
          2.  Link key for the remote device is present.
          3.  Remote is SSP capable.
      */
-    else if ((p_dev_rec->sec_rec.link_key_type <= BTM_LKEY_TYPE_REMOTE_UNIT) &&
+    else if ((p_dev_rec->link_key_type <= BTM_LKEY_TYPE_REMOTE_UNIT) &&
              (((status == HCI_ERR_AUTH_FAILURE) ||
                (status == HCI_ERR_KEY_MISSING) ||
                (status == HCI_ERR_HOST_REJECT_SECURITY) ||
@@ -3548,8 +3712,8 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
                (status == HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED) ||
                (status == HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE) ||
                (status == HCI_ERR_REPEATED_ATTEMPTS)))) {
-      p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
-      p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN << bit_shift);
+      p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+      p_dev_rec->sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN << bit_shift);
 
 #ifdef BRCM_NOT_4_BTE
       /* If we rejected pairing, pass this special result code */
@@ -3590,19 +3754,18 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
    * the authenticate requirement bit.  Reset the pairing state machine
    * and inform l2cap if the directed bonding was initiated.
    */
-  if (is_pairing_device &&
-      (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
-    if (p_dev_rec->sec_rec.link_key_not_sent) {
-      p_dev_rec->sec_rec.link_key_not_sent = false;
+  if (is_pairing_device && (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
+    if (p_dev_rec->link_key_not_sent) {
+      p_dev_rec->link_key_not_sent = false;
       btm_send_link_key_notif(p_dev_rec);
     }
 
-    p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+    p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
 
     /* remember flag before it is initialized */
     const bool is_pair_flags_we_started_dd =
         btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD;
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
     if (is_pair_flags_we_started_dd) {
       /* Let l2cap start bond timer */
@@ -3613,7 +3776,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
     BTM_LogHistory(kBtmLogTag, bda, "Dedicated bonding",
                    base::StringPrintf("Initiated:%c pairing_flag:0x%02x",
                                       (is_pair_flags_we_started_dd) ? 'T' : 'F',
-                                      p_dev_rec->sec_rec.sec_flags));
+                                      p_dev_rec->sec_flags));
   }
 
   p_dev_rec->hci_handle = handle;
@@ -3633,18 +3796,18 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
   /* Initialize security flags.  We need to do that because some            */
   /* authorization complete could have come after the connection is dropped */
   /* and that would set wrong flag that link has been authorized already    */
-  p_dev_rec->sec_rec.sec_flags &=
+  p_dev_rec->sec_flags &=
       ~((BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED | BTM_SEC_ROLE_SWITCHED)
         << bit_shift);
 
   if (enc_mode != HCI_ENCRYPT_MODE_DISABLED)
-    p_dev_rec->sec_rec.sec_flags |=
+    p_dev_rec->sec_flags |=
         ((BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED) << bit_shift);
 
-  if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
-    p_dev_rec->sec_rec.sec_flags |= (BTM_SEC_16_DIGIT_PIN_AUTHED << bit_shift);
+  if (p_dev_rec->pin_code_length >= 16 ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+    p_dev_rec->sec_flags |= (BTM_SEC_16_DIGIT_PIN_AUTHED << bit_shift);
   }
 
   /* After connection is established we perform security if we do not know */
@@ -3652,7 +3815,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
   /* been scheduled while connection was down */
   LOG_DEBUG("Is connection locally initiated:%s",
             logbool(p_dev_rec->is_originator).c_str());
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) ||
+  if (!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) ||
       p_dev_rec->is_originator) {
     res = btm_sec_execute_procedure(p_dev_rec);
     if (res != BTM_CMD_STARTED)
@@ -3712,8 +3875,8 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
       (btm_sec_cb.pairing_bda == p_dev_rec->bd_addr)) {
     LOG_DEBUG("Disconnected while pairing process active handle:0x%04x",
               handle);
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
+    p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
 
     /* If the disconnection reason is REPEATED_ATTEMPTS,
        send this error message to complete callback function
@@ -3743,9 +3906,8 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
   LOG_DEBUG(
       "Disconnection complete device:%s name:%s state:%s reason:%s sec_req:%x",
       ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr), p_dev_rec->sec_bd_name,
-      tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state),
-      hci_reason_code_text(reason).c_str(),
-      p_dev_rec->sec_rec.security_required);
+      btm_pair_state_descr(btm_sec_cb.pairing_state),
+      hci_reason_code_text(reason).c_str(), p_dev_rec->security_required);
 
   // TODO Should this be gated by the transport check below ?
   btm_ble_update_mode_operation(HCI_ROLE_UNKNOWN, &p_dev_rec->bd_addr,
@@ -3754,32 +3916,31 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
 
   if (transport == BT_TRANSPORT_LE) {
     p_dev_rec->ble_hci_handle = HCI_INVALID_HANDLE;
-    p_dev_rec->sec_rec.sec_flags &=
-        ~(BTM_SEC_LE_AUTHENTICATED | BTM_SEC_LE_ENCRYPTED |
-          BTM_SEC_ROLE_SWITCHED);
-    p_dev_rec->sec_rec.enc_key_size = 0;
+    p_dev_rec->sec_flags &= ~(BTM_SEC_LE_AUTHENTICATED | BTM_SEC_LE_ENCRYPTED |
+                              BTM_SEC_ROLE_SWITCHED);
+    p_dev_rec->enc_key_size = 0;
     p_dev_rec->suggested_tx_octets = 0;
 
-    if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) == 0) {
-      p_dev_rec->sec_rec.sec_flags &=
+    if ((p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) == 0) {
+      p_dev_rec->sec_flags &=
           ~(BTM_SEC_LE_LINK_KEY_AUTHED | BTM_SEC_LE_AUTHENTICATED);
     }
   } else {
     p_dev_rec->hci_handle = HCI_INVALID_HANDLE;
-    p_dev_rec->sec_rec.sec_flags &=
+    p_dev_rec->sec_flags &=
         ~(BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED | BTM_SEC_ROLE_SWITCHED |
           BTM_SEC_16_DIGIT_PIN_AUTHED);
 
     // Remove temporary key.
-    if (p_dev_rec->sec_rec.bond_type == BOND_TYPE_TEMPORARY)
-      p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LINK_KEY_KNOWN);
+    if (p_dev_rec->bond_type == BOND_TYPE_TEMPORARY)
+      p_dev_rec->sec_flags &= ~(BTM_SEC_LINK_KEY_KNOWN);
   }
 
   /* Some devices hardcode sample LTK value from spec, instead of generating
    * one. Treat such devices as insecure, and remove such bonds on
    * disconnection.
    */
-  if (is_sample_ltk(p_dev_rec->sec_rec.ble_keys.pltk)) {
+  if (is_sample_ltk(p_dev_rec->ble_keys.pltk)) {
     LOG_INFO("removing bond to device that used sample LTK: %s",
              ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr));
 
@@ -3787,23 +3948,23 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
     return;
   }
 
-  if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH) {
+  if (p_dev_rec->sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH) {
     LOG_DEBUG("Waiting for other transport to disconnect current:%s",
               bt_transport_text(transport).c_str());
-    p_dev_rec->sec_rec.sec_state = (transport == BT_TRANSPORT_LE)
-                                       ? BTM_SEC_STATE_DISCONNECTING
-                                       : BTM_SEC_STATE_DISCONNECTING_BLE;
+    p_dev_rec->sec_state = (transport == BT_TRANSPORT_LE)
+                               ? BTM_SEC_STATE_DISCONNECTING
+                               : BTM_SEC_STATE_DISCONNECTING_BLE;
     return;
   }
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
-  p_dev_rec->sec_rec.security_required = BTM_SEC_NONE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->security_required = BTM_SEC_NONE;
 
-  if (p_dev_rec->sec_rec.p_callback != nullptr) {
-    tBTM_SEC_CALLBACK* p_callback = p_dev_rec->sec_rec.p_callback;
+  if (p_dev_rec->p_callback != nullptr) {
+    tBTM_SEC_CALLBACK* p_callback = p_dev_rec->p_callback;
     /* when the peer device time out the authentication before
        we do, this call back must be reset here */
-    p_dev_rec->sec_rec.p_callback = nullptr;
-    (*p_callback)(&p_dev_rec->bd_addr, transport, p_dev_rec->sec_rec.p_ref_data,
+    p_dev_rec->p_callback = nullptr;
+    (*p_callback)(&p_dev_rec->bd_addr, transport, p_dev_rec->p_ref_data,
                   BTM_ERR_PROCESSING);
     LOG_DEBUG("Cleaned up pending security state device:%s transport:%s",
               ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr),
@@ -3893,48 +4054,48 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
   btm_restore_mode();
 
   if (key_type != BTM_LKEY_TYPE_CHANGED_COMB)
-    p_dev_rec->sec_rec.link_key_type = key_type;
+    p_dev_rec->link_key_type = key_type;
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
+  p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
 
   /*
    * Until this point in time, we do not know if MITM was enabled, hence we
    * add the extended security flag here.
    */
-  if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+  if (p_dev_rec->pin_code_length >= 16 ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+    p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
+    p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
   }
 
   /* BR/EDR connection, update the encryption key size to be 16 as always */
-  p_dev_rec->sec_rec.enc_key_size = 16;
-  p_dev_rec->sec_rec.link_key = link_key;
+  p_dev_rec->enc_key_size = 16;
+  p_dev_rec->link_key = link_key;
 
   if ((btm_sec_cb.pairing_state != BTM_PAIR_STATE_IDLE) &&
       (btm_sec_cb.pairing_bda == p_bda)) {
     if (btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD)
       we_are_bonding = true;
     else
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
   }
 
   /* save LTK derived LK no matter what */
   if (ltk_derived_lk) {
     if (btm_sec_cb.api.p_link_key_callback) {
       LOG_VERBOSE("Save LTK derived LK (key_type = %d)",
-                  p_dev_rec->sec_rec.link_key_type);
+                  p_dev_rec->link_key_type);
       (*btm_sec_cb.api.p_link_key_callback)(
           p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name, link_key,
-          p_dev_rec->sec_rec.link_key_type, true /* is_ctkd */);
+          p_dev_rec->link_key_type, true /* is_ctkd */);
     }
   } else {
-    if ((p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256) ||
-        (p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
-      p_dev_rec->sec_rec.new_encryption_key_is_p256 = true;
+    if ((p_dev_rec->link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256) ||
+        (p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+      p_dev_rec->new_encryption_key_is_p256 = true;
       LOG_VERBOSE("set new_encr_key_256 to %d",
-                  p_dev_rec->sec_rec.new_encryption_key_is_p256);
+                  p_dev_rec->new_encryption_key_is_p256);
     }
   }
 
@@ -3942,14 +4103,14 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
    */
   /* resolved. Unless it is a HID Device and we really need to send all link
    * keys. */
-  if ((!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) &&
+  if ((!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) &&
        ((p_dev_rec->dev_class[1] & BTM_COD_MAJOR_CLASS_MASK) !=
         BTM_COD_MAJOR_PERIPHERAL)) &&
       !ltk_derived_lk) {
     LOG_VERBOSE("Delayed BDA: %s, Type: %d", ADDRESS_TO_LOGGABLE_CSTR(p_bda),
                 key_type);
 
-    p_dev_rec->sec_rec.link_key_not_sent = true;
+    p_dev_rec->link_key_not_sent = true;
 
     /* If it is for bonding nothing else will follow, so we need to start name
      * resolution */
@@ -3958,7 +4119,7 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
     }
 
     LOG_VERBOSE("rmt_io_caps:%d, sec_flags:x%x, dev_class[1]:x%02x",
-                p_dev_rec->sec_rec.rmt_io_caps, p_dev_rec->sec_rec.sec_flags,
+                p_dev_rec->rmt_io_caps, p_dev_rec->sec_flags,
                 p_dev_rec->dev_class[1]);
     return;
   }
@@ -3966,7 +4127,7 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
 /* We will save link key only if the user authorized it - BTE report link key in
  * all cases */
 #ifdef BRCM_NONE_BTE
-  if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_AUTHED)
+  if (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_AUTHED)
 #endif
   {
     if (btm_sec_cb.api.p_link_key_callback) {
@@ -3974,11 +4135,11 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
         LOG_VERBOSE(
             "btm_sec_link_key_notification()  LTK derived LK is saved already"
             " (key_type = %d)",
-            p_dev_rec->sec_rec.link_key_type);
+            p_dev_rec->link_key_type);
       } else {
         (*btm_sec_cb.api.p_link_key_callback)(
             p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name, link_key,
-            p_dev_rec->sec_rec.link_key_type, false /* is_ctkd */);
+            p_dev_rec->link_key_type, false /* is_ctkd */);
       }
     }
   }
@@ -3998,7 +4159,7 @@ void btm_sec_link_key_request(const RawAddress bda) {
 
   LOG_VERBOSE("bda: %s", ADDRESS_TO_LOGGABLE_CSTR(bda));
   if (!concurrentPeerAuthIsEnabled()) {
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+    p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
   }
 
   if ((btm_sec_cb.pairing_state == BTM_PAIR_STATE_WAIT_PIN_REQ) &&
@@ -4011,8 +4172,8 @@ void btm_sec_link_key_request(const RawAddress bda) {
     btsnd_hcic_link_key_neg_reply(bda);
     return;
   }
-  if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
-    btsnd_hcic_link_key_req_reply(bda, p_dev_rec->sec_rec.link_key);
+  if (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
+    btsnd_hcic_link_key_req_reply(bda, p_dev_rec->link_key);
     return;
   }
 
@@ -4044,8 +4205,7 @@ static void btm_sec_pairing_timeout(void* /* data */) {
   p_dev_rec = btm_find_dev(p_cb->pairing_bda);
 
   LOG_VERBOSE("State: %s   Flags: %u",
-              tBTM_SEC_CB::btm_pair_state_descr(p_cb->pairing_state),
-              p_cb->pairing_flags);
+              btm_pair_state_descr(p_cb->pairing_state), p_cb->pairing_flags);
 
   switch (p_cb->pairing_state) {
     case BTM_PAIR_STATE_WAIT_PIN_REQ:
@@ -4055,7 +4215,7 @@ static void btm_sec_pairing_timeout(void* /* data */) {
     case BTM_PAIR_STATE_WAIT_LOCAL_PIN:
       if ((btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_PRE_FETCH_PIN) == 0)
         btsnd_hcic_pin_code_neg_reply(p_cb->pairing_bda);
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       /* We need to notify the UI that no longer need the PIN */
       if (btm_sec_cb.api.p_auth_complete_callback) {
         if (p_dev_rec == NULL) {
@@ -4069,14 +4229,14 @@ static void btm_sec_pairing_timeout(void* /* data */) {
 
     case BTM_PAIR_STATE_WAIT_NUMERIC_CONFIRM:
       btsnd_hcic_user_conf_reply(p_cb->pairing_bda, false);
-      /* btm_sec_cb.change_pairing_state (BTM_PAIR_STATE_IDLE); */
+      /* btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE); */
       break;
 
     case BTM_PAIR_STATE_KEY_ENTRY:
       if (btm_sec_cb.devcb.loc_io_caps != BTM_IO_CAP_NONE) {
         btsnd_hcic_user_passkey_neg_reply(p_cb->pairing_bda);
       } else {
-        btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+        btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       }
       break;
 
@@ -4085,12 +4245,12 @@ static void btm_sec_pairing_timeout(void* /* data */) {
       btsnd_hcic_io_cap_req_reply(p_cb->pairing_bda,
                                   btm_sec_cb.devcb.loc_io_caps, BTM_OOB_NONE,
                                   auth_req);
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       break;
 
     case BTM_PAIR_STATE_WAIT_LOCAL_OOB_RSP:
       btsnd_hcic_rem_oob_neg_reply(p_cb->pairing_bda);
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       break;
 
     case BTM_PAIR_STATE_WAIT_DISCONNECT:
@@ -4105,14 +4265,14 @@ static void btm_sec_pairing_timeout(void* /* data */) {
       btm_sec_send_hci_disconnect(
           p_dev_rec, HCI_ERR_AUTH_FAILURE, p_dev_rec->hci_handle,
           "stack::btm::btm_sec::btm_sec_pairing_timeout");
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       break;
 
     case BTM_PAIR_STATE_WAIT_AUTH_COMPLETE:
     case BTM_PAIR_STATE_GET_REM_NAME:
       /* We need to notify the UI that timeout has happened while waiting for
        * authentication*/
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       if (btm_sec_cb.api.p_auth_complete_callback) {
         if (p_dev_rec == NULL) {
           name[0] = 0;
@@ -4126,8 +4286,8 @@ static void btm_sec_pairing_timeout(void* /* data */) {
 
     default:
       LOG_WARN("not processed state: %s",
-               tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state));
-      btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_IDLE);
+               btm_pair_state_descr(btm_sec_cb.pairing_state));
+      btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
       break;
   }
 }
@@ -4151,7 +4311,7 @@ void btm_sec_pin_code_request(const RawAddress p_bda) {
 
   LOG_DEBUG("Controller requests PIN code device:%s state:%s",
             ADDRESS_TO_LOGGABLE_CSTR(p_bda),
-            tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state));
+            btm_pair_state_descr(btm_sec_cb.pairing_state));
 
   RawAddress local_bd_addr = *controller_get_interface()->get_address();
   if (p_bda == local_bd_addr) {
@@ -4167,7 +4327,7 @@ void btm_sec_pin_code_request(const RawAddress p_bda) {
     } else if ((btm_sec_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ) ||
                p_bda != btm_sec_cb.pairing_bda) {
       LOG_WARN("btm_sec_pin_code_request() rejected - state: %s",
-               tBTM_SEC_CB::btm_pair_state_descr(btm_sec_cb.pairing_state));
+               btm_pair_state_descr(btm_sec_cb.pairing_state));
       btsnd_hcic_pin_code_neg_reply(p_bda);
       return;
     }
@@ -4185,7 +4345,7 @@ void btm_sec_pin_code_request(const RawAddress p_bda) {
 
   if (!p_cb->pairing_disabled && (p_cb->cfg.pin_type == HCI_PIN_TYPE_FIXED)) {
     LOG_VERBOSE("btm_sec_pin_code_request fixed pin replying");
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
     btsnd_hcic_pin_code_req_reply(p_bda, p_cb->cfg.pin_code_len,
                                   p_cb->cfg.pin_code);
     return;
@@ -4211,7 +4371,7 @@ void btm_sec_pin_code_request(const RawAddress p_bda) {
     /* is not forced to be secure - found a FW issue, so we can not do this
     btm_restore_mode(); */
 
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
   }
 
   /* If pairing disabled OR (no PIN callback and not bonding) */
@@ -4238,7 +4398,7 @@ void btm_sec_pin_code_request(const RawAddress p_bda) {
   }
   /* Notify upper layer of PIN request and start expiration timer */
   else {
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_PIN);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_PIN);
     /* Pin code request can not come at the same time as connection request */
     p_cb->connecting_bda = p_bda;
     memcpy(p_cb->connecting_dc, p_dev_rec->dev_class, DEV_CLASS_LEN);
@@ -4249,14 +4409,14 @@ void btm_sec_pin_code_request(const RawAddress p_bda) {
     /* device, so HCI level is flow controlled */
     /* Also cannot send remote name request while paging, i.e. connection is not
      * completed */
-    if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) {
+    if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) {
       LOG_VERBOSE("btm_sec_pin_code_request going for callback");
 
       btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
       if (p_cb->api.p_pin_callback) {
         (*p_cb->api.p_pin_callback)(
             p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name,
-            (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+            (p_dev_rec->required_security_flags_for_pairing &
              BTM_SEC_IN_MIN_16_DIGIT_PIN));
       }
     } else {
@@ -4324,21 +4484,20 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
   CHECK(p_dev_rec != nullptr);
   LOG_DEBUG(
       "security_required:0x%x security_flags:0x%x security_state:%s[%hhu]",
-      p_dev_rec->sec_rec.security_required, p_dev_rec->sec_rec.sec_flags,
-      security_state_text(
-          static_cast<tSECURITY_STATE>(p_dev_rec->sec_rec.sec_state))
+      p_dev_rec->security_required, p_dev_rec->sec_flags,
+      security_state_text(static_cast<tSECURITY_STATE>(p_dev_rec->sec_state))
           .c_str(),
-      p_dev_rec->sec_rec.sec_state);
+      p_dev_rec->sec_state);
 
-  if (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_IDLE &&
-      p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_LE_ENCRYPTING) {
+  if (p_dev_rec->sec_state != BTM_SEC_STATE_IDLE &&
+      p_dev_rec->sec_state != BTM_SEC_STATE_LE_ENCRYPTING) {
     LOG_INFO("No immediate action taken in busy state: %s",
-             security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+              security_state_text(p_dev_rec->sec_state).c_str());
     return (BTM_CMD_STARTED);
   }
 
   /* If any security is required, get the name first */
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) &&
+  if (!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) &&
       (p_dev_rec->hci_handle != HCI_INVALID_HANDLE)) {
     LOG_DEBUG("Security Manager: Start get name");
     if (!btm_sec_start_get_name(p_dev_rec)) {
@@ -4354,21 +4513,23 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
     bool start_auth = false;
 
     // Check link status of BR/EDR
-    if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) {
+    if (!(p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) {
       if (p_dev_rec->IsLocallyInitiated()) {
-        if (p_dev_rec->sec_rec.security_required & BTM_SEC_OUT_AUTHENTICATE) {
-          LOG_DEBUG("Outgoing authentication Required");
+        if (p_dev_rec->security_required &
+            (BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_ENCRYPT)) {
+          LOG_DEBUG("Outgoing authentication/encryption Required");
           start_auth = true;
         }
       } else {
-        if (p_dev_rec->sec_rec.security_required & BTM_SEC_IN_AUTHENTICATE) {
-          LOG_DEBUG("Incoming authentication Required");
+        if (p_dev_rec->security_required &
+            (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT)) {
+          LOG_DEBUG("Incoming authentication/encryption Required");
           start_auth = true;
         }
       }
     }
 
-    if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED)) {
+    if (!(p_dev_rec->sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED)) {
       /*
        * We rely on BTM_SEC_16_DIGIT_PIN_AUTHED being set if MITM is in use,
        * as 16 DIGIT is only needed if MITM is not used. Unfortunately, the
@@ -4376,8 +4537,7 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
        * authenticated connections, hence we cannot distinguish here.
        */
       if (!p_dev_rec->IsLocallyInitiated()) {
-        if (p_dev_rec->sec_rec.security_required &
-            BTM_SEC_IN_MIN_16_DIGIT_PIN) {
+        if (p_dev_rec->security_required & BTM_SEC_IN_MIN_16_DIGIT_PIN) {
           LOG_DEBUG("BTM_SEC_IN_MIN_16_DIGIT_PIN Required");
           start_auth = true;
         }
@@ -4398,12 +4558,11 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
        * or even IOP issues, if a reconnect causes a new connection that
        * requires an upgrade.
        */
-      if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) &&
-          (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED) &&
-           (!p_dev_rec->IsLocallyInitiated() &&
-            (p_dev_rec->sec_rec.security_required &
-             BTM_SEC_IN_MIN_16_DIGIT_PIN)))) {
-        p_dev_rec->sec_rec.sec_flags &=
+      if ((p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) &&
+          (!(p_dev_rec->sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED) &&
+          (!p_dev_rec->IsLocallyInitiated() &&
+            (p_dev_rec->security_required & BTM_SEC_IN_MIN_16_DIGIT_PIN)))) {
+        p_dev_rec->sec_flags &=
             ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED |
               BTM_SEC_AUTHENTICATED);
       }
@@ -4415,39 +4574,39 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
 
   /* If connection is not encrypted and encryption is required */
   /* start encryption and return PENDING to the caller */
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED) &&
+  if (!(p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED) &&
       ((p_dev_rec->IsLocallyInitiated() &&
-        (p_dev_rec->sec_rec.security_required & BTM_SEC_OUT_ENCRYPT)) ||
+        (p_dev_rec->security_required & BTM_SEC_OUT_ENCRYPT)) ||
        (!p_dev_rec->IsLocallyInitiated() &&
-        (p_dev_rec->sec_rec.security_required & BTM_SEC_IN_ENCRYPT))) &&
+        (p_dev_rec->security_required & BTM_SEC_IN_ENCRYPT))) &&
       (p_dev_rec->hci_handle != HCI_INVALID_HANDLE)) {
     LOG_VERBOSE("Security Manager: Start encryption");
 
     btsnd_hcic_set_conn_encrypt(p_dev_rec->hci_handle, true);
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_ENCRYPTING;
+    p_dev_rec->sec_state = BTM_SEC_STATE_ENCRYPTING;
     return (BTM_CMD_STARTED);
   } else {
     LOG_DEBUG("Encryption not required");
   }
 
-  if ((p_dev_rec->sec_rec.security_required & BTM_SEC_MODE4_LEVEL4) &&
-      (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+  if ((p_dev_rec->security_required & BTM_SEC_MODE4_LEVEL4) &&
+      (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
     LOG_VERBOSE(
         "Security Manager: SC only service, but link key type is 0x%02x -"
         "security failure",
-        p_dev_rec->sec_rec.link_key_type);
+        p_dev_rec->link_key_type);
     return (BTM_FAILED_ON_SECURITY);
   }
 
-  if (access_secure_service_from_temp_bond(
-          p_dev_rec, p_dev_rec->IsLocallyInitiated(),
-          p_dev_rec->sec_rec.security_required)) {
+  if (access_secure_service_from_temp_bond(p_dev_rec,
+                                           p_dev_rec->IsLocallyInitiated(),
+                                           p_dev_rec->security_required)) {
     LOG_ERROR("Trying to access a secure service from a temp bonding, rejecting");
     return (BTM_FAILED_ON_SECURITY);
   }
 
   /* All required  security procedures already established */
-  p_dev_rec->sec_rec.security_required &=
+  p_dev_rec->security_required &=
       ~(BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_IN_AUTHENTICATE |
         BTM_SEC_OUT_ENCRYPT | BTM_SEC_IN_ENCRYPT);
 
@@ -4468,7 +4627,7 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
 static bool btm_sec_start_get_name(tBTM_SEC_DEV_REC* p_dev_rec) {
   if (!BTM_IsDeviceUp()) return false;
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_GETTING_NAME;
+  p_dev_rec->sec_state = BTM_SEC_STATE_GETTING_NAME;
 
   /* 0 and NULL are as timeout and callback params because they are not used in
    * security get name case */
@@ -4518,16 +4677,15 @@ static void btm_sec_auth_timer_timeout(void* data) {
     LOG_INFO("invalid device or not found");
   } else if (btm_dev_authenticated(p_dev_rec)) {
     LOG_INFO("device is already authenticated");
-    if (p_dev_rec->sec_rec.p_callback) {
-      (*p_dev_rec->sec_rec.p_callback)(&p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR,
-                                       p_dev_rec->sec_rec.p_ref_data,
-                                       BTM_SUCCESS);
+    if (p_dev_rec->p_callback) {
+      (*p_dev_rec->p_callback)(&p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR,
+                               p_dev_rec->p_ref_data, BTM_SUCCESS);
     }
-  } else if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+  } else if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
     LOG_INFO("device is in the process of authenticating");
   } else {
     LOG_INFO("starting authentication");
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+    p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
     btsnd_hcic_auth_request(p_dev_rec->hci_handle);
   }
 }
@@ -4568,7 +4726,7 @@ static void btm_send_link_key_notif(tBTM_SEC_DEV_REC* p_dev_rec) {
   if (btm_sec_cb.api.p_link_key_callback)
     (*btm_sec_cb.api.p_link_key_callback)(
         p_dev_rec->bd_addr, p_dev_rec->dev_class, p_dev_rec->sec_bd_name,
-        p_dev_rec->sec_rec.link_key, p_dev_rec->sec_rec.link_key_type, false);
+        p_dev_rec->link_key, p_dev_rec->link_key_type, false);
 }
 
 /*******************************************************************************
@@ -4596,45 +4754,45 @@ static void btm_restore_mode(void) {
 
 /*******************************************************************************
  *
- * Function         change_pairing_state
+ * Function         btm_sec_change_pairing_state
  *
  * Description      This function is called to change pairing state
  *
  ******************************************************************************/
-void tBTM_SEC_CB::change_pairing_state(tBTM_PAIRING_STATE new_state) {
-  tBTM_PAIRING_STATE old_state = pairing_state;
+static void btm_sec_change_pairing_state(tBTM_PAIRING_STATE new_state) {
+  tBTM_PAIRING_STATE old_state = btm_sec_cb.pairing_state;
 
   LOG_DEBUG("Pairing state changed %s => %s pairing_flags:0x%x",
-            tBTM_SEC_CB::btm_pair_state_descr(pairing_state),
-            tBTM_SEC_CB::btm_pair_state_descr(new_state), pairing_flags);
+            btm_pair_state_descr(btm_sec_cb.pairing_state),
+            btm_pair_state_descr(new_state), btm_sec_cb.pairing_flags);
 
-  if (pairing_state != new_state) {
+  if (btm_sec_cb.pairing_state != new_state) {
     BTM_LogHistory(
         kBtmLogTag, btm_sec_cb.pairing_bda, "Pairing state changed",
         base::StringPrintf("%s => %s",
-                           tBTM_SEC_CB::btm_pair_state_descr(pairing_state),
-                           tBTM_SEC_CB::btm_pair_state_descr(new_state)));
+                           btm_pair_state_descr(btm_sec_cb.pairing_state),
+                           btm_pair_state_descr(new_state)));
   }
-  pairing_state = new_state;
+  btm_sec_cb.pairing_state = new_state;
 
   if (new_state == BTM_PAIR_STATE_IDLE) {
-    alarm_cancel(pairing_timer);
+    alarm_cancel(btm_sec_cb.pairing_timer);
 
-    pairing_flags = 0;
-    pin_code_len = 0;
+    btm_sec_cb.pairing_flags = 0;
+    btm_sec_cb.pin_code_len = 0;
 
     /* Make sure the the lcb shows we are not bonding */
-    l2cu_update_lcb_4_bonding(pairing_bda, false);
+    l2cu_update_lcb_4_bonding(btm_sec_cb.pairing_bda, false);
 
     btm_restore_mode();
     btm_sec_check_pending_reqs();
     btm_inq_clear_ssp();
 
-    pairing_bda = RawAddress::kAny;
+    btm_sec_cb.pairing_bda = RawAddress::kAny;
   } else {
     /* If transitioning out of idle, mark the lcb as bonding */
     if (old_state == BTM_PAIR_STATE_IDLE)
-      l2cu_update_lcb_4_bonding(pairing_bda, true);
+      l2cu_update_lcb_4_bonding(btm_sec_cb.pairing_bda, true);
 
     alarm_set_on_mloop(btm_sec_cb.pairing_timer, BTM_SEC_TIMEOUT_VALUE * 1000,
                        btm_sec_pairing_timeout, NULL);
@@ -4648,7 +4806,7 @@ void tBTM_SEC_CB::change_pairing_state(tBTM_PAIRING_STATE new_state) {
  * Description      Return state description for tracing
  *
  ******************************************************************************/
-const char* tBTM_SEC_CB::btm_pair_state_descr(tBTM_PAIRING_STATE state) {
+static const char* btm_pair_state_descr(tBTM_PAIRING_STATE state) {
   switch (state) {
     case BTM_PAIR_STATE_IDLE:
       return ("IDLE");
@@ -4693,15 +4851,15 @@ void btm_sec_dev_rec_cback_event(tBTM_SEC_DEV_REC* p_dev_rec,
   LOG_DEBUG("transport=%s, btm_status=%s", is_le_transport ? "le" : "classic",
             btm_status_text(btm_status).c_str());
 
-  tBTM_SEC_CALLBACK* p_callback = p_dev_rec->sec_rec.p_callback;
-  p_dev_rec->sec_rec.p_callback = NULL;
+  tBTM_SEC_CALLBACK* p_callback = p_dev_rec->p_callback;
+  p_dev_rec->p_callback = NULL;
   if (p_callback != nullptr) {
     if (is_le_transport) {
       (*p_callback)(&p_dev_rec->ble.pseudo_addr, BT_TRANSPORT_LE,
-                    p_dev_rec->sec_rec.p_ref_data, btm_status);
+                    p_dev_rec->p_ref_data, btm_status);
     } else {
       (*p_callback)(&p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR,
-                    p_dev_rec->sec_rec.p_ref_data, btm_status);
+                    p_dev_rec->p_ref_data, btm_status);
     }
   }
 
@@ -4767,7 +4925,7 @@ static bool btm_sec_check_prefetch_pin(tBTM_SEC_DEV_REC* p_dev_rec) {
       btsnd_hcic_write_auth_enable(true);
     }
   } else {
-    btm_sec_cb.change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_PIN);
+    btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_PIN);
 
     /* If we got a PIN, use that, else try to get one */
     if (btm_sec_cb.pin_code_len) {
@@ -4782,7 +4940,7 @@ static bool btm_sec_check_prefetch_pin(tBTM_SEC_DEV_REC* p_dev_rec) {
           btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
         (btm_sec_cb.api.p_pin_callback)(
             p_dev_rec->bd_addr, p_dev_rec->dev_class, p_dev_rec->sec_bd_name,
-            (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+            (p_dev_rec->required_security_flags_for_pairing &
              BTM_SEC_IN_MIN_16_DIGIT_PIN));
       }
     }
@@ -4845,7 +5003,7 @@ static void btm_sec_check_pending_enc_req(tBTM_SEC_DEV_REC* p_dev_rec,
           p_e->sec_act == BTM_BLE_SEC_ENCRYPT ||
           p_e->sec_act == BTM_BLE_SEC_ENCRYPT_NO_MITM ||
           (p_e->sec_act == BTM_BLE_SEC_ENCRYPT_MITM &&
-           p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_AUTHENTICATED)) {
+           p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED)) {
         if (p_e->p_callback)
           (*p_e->p_callback)(&p_dev_rec->bd_addr, transport, p_e->p_ref_data,
                              res);
@@ -4888,7 +5046,7 @@ static uint16_t btm_sec_set_serv_level4_flags(uint16_t cur_security,
  ******************************************************************************/
 void btm_sec_clear_ble_keys(tBTM_SEC_DEV_REC* p_dev_rec) {
   LOG_VERBOSE("Clearing BLE Keys");
-  memset(&p_dev_rec->sec_rec.ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
+  memset(&p_dev_rec->ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
 
   btm_ble_resolving_list_remove_dev(p_dev_rec);
 }
@@ -4898,13 +5056,22 @@ void btm_sec_clear_ble_keys(tBTM_SEC_DEV_REC* p_dev_rec) {
  * Function         btm_sec_is_a_bonded_dev
  *
  * Description       Is the specified device is a bonded device
- *                   (either on BR/EDR or LE)
  *
  * Returns          true - dev is bonded
  *
  ******************************************************************************/
 bool btm_sec_is_a_bonded_dev(const RawAddress& bda) {
-  return btm_sec_cb.IsDeviceBonded(bda);
+  tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bda);
+  bool is_bonded = false;
+
+  if (p_dev_rec && ((p_dev_rec->ble_keys.key_type &&
+                     (p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN)) ||
+                    (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN))) {
+    is_bonded = true;
+  }
+  LOG_DEBUG("Device record bonded check peer:%s is_bonded:%s",
+            ADDRESS_TO_LOGGABLE_CSTR(bda), logbool(is_bonded).c_str());
+  return is_bonded;
 }
 
 /*******************************************************************************
@@ -4925,10 +5092,10 @@ static bool btm_sec_use_smp_br_chnl(tBTM_SEC_DEV_REC* p_dev_rec) {
   uint32_t ext_feat;
   uint8_t chnl_mask[L2CAP_FIXED_CHNL_ARRAY_SIZE];
 
-  LOG_VERBOSE("link_key_type = 0x%x", p_dev_rec->sec_rec.link_key_type);
+  LOG_VERBOSE("link_key_type = 0x%x", p_dev_rec->link_key_type);
 
-  if ((p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_UNAUTH_COMB_P_256) &&
-      (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256))
+  if ((p_dev_rec->link_key_type != BTM_LKEY_TYPE_UNAUTH_COMB_P_256) &&
+      (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256))
     return false;
 
   if (!L2CA_GetPeerFeatures(p_dev_rec->bd_addr, &ext_feat, chnl_mask))
@@ -4961,7 +5128,7 @@ void btm_sec_set_peer_sec_caps(uint16_t hci_handle, bool ssp_supported,
 
   uint8_t req_pend = (p_dev_rec->sm4 & BTM_SM4_REQ_PEND);
 
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) ||
+  if (!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) ||
       p_dev_rec->is_originator) {
     tBTM_STATUS btm_status = btm_sec_execute_procedure(p_dev_rec);
     if (btm_status != BTM_CMD_STARTED) {
diff --git a/system/stack/btm/btm_sec.h b/system/stack/btm/btm_sec.h
index 05938e2ee2..fcde316559 100644
--- a/system/stack/btm/btm_sec.h
+++ b/system/stack/btm/btm_sec.h
@@ -79,6 +79,19 @@ bool BTM_SecAddRmtNameNotifyCallback(tBTM_RMT_NAME_CALLBACK* p_callback);
  ******************************************************************************/
 bool BTM_SecDeleteRmtNameNotifyCallback(tBTM_RMT_NAME_CALLBACK* p_callback);
 
+/*******************************************************************************
+ *
+ * Function         BTM_GetSecurityFlagsByTransport
+ *
+ * Description      Get security flags for the device on a particular transport
+ *
+ * Returns          bool    true or false is device found
+ *
+ ******************************************************************************/
+bool BTM_GetSecurityFlagsByTransport(const RawAddress& bd_addr,
+                                     uint8_t* p_sec_flags,
+                                     tBT_TRANSPORT transport);
+
 bool BTM_IsEncrypted(const RawAddress& bd_addr, tBT_TRANSPORT transport);
 bool BTM_IsLinkKeyAuthed(const RawAddress& bd_addr, tBT_TRANSPORT transport);
 bool BTM_IsLinkKeyKnown(const RawAddress& bd_addr, tBT_TRANSPORT transport);
diff --git a/system/stack/btm/btm_sec_cb.cc b/system/stack/btm/btm_sec_cb.cc
index 7fee5aa6e9..8cf04435e8 100644
--- a/system/stack/btm/btm_sec_cb.cc
+++ b/system/stack/btm/btm_sec_cb.cc
@@ -15,20 +15,15 @@
  *
  */
 
-#define LOG_TAG "SEC_CB"
-
 #include "stack/btm/btm_sec_cb.h"
 
 #include <cstdint>
 
 #include "internal_include/stack_config.h"
-#include "os/log.h"
 #include "osi/include/allocator.h"
 #include "osi/include/fixed_queue.h"
 #include "osi/include/list.h"
-#include "stack/btm/btm_dev.h"
 #include "stack/btm/security_device_record.h"
-#include "stack/include/bt_psm_types.h"
 #include "types/raw_address.h"
 
 void tBTM_SEC_CB::Init(uint8_t initial_security_mode) {
@@ -111,247 +106,4 @@ tBTM_SEC_SERV_REC* tBTM_SEC_CB::find_first_serv_rec(bool is_originator,
       return (p_serv_rec);
   }
   return (NULL);
-}
-
-tBTM_SEC_REC* tBTM_SEC_CB::getSecRec(const RawAddress bd_addr) {
-  tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
-  if (p_dev_rec) {
-    return &p_dev_rec->sec_rec;
-  }
-  return nullptr;
-}
-
-bool tBTM_SEC_CB::IsDeviceEncrypted(const RawAddress bd_addr,
-                                    tBT_TRANSPORT transport) {
-  tBTM_SEC_REC* sec_rec = getSecRec(bd_addr);
-  if (sec_rec) {
-    if (transport == BT_TRANSPORT_BR_EDR) {
-      return sec_rec->is_device_encrypted();
-    } else if (transport == BT_TRANSPORT_LE) {
-      return sec_rec->is_le_device_encrypted();
-    }
-    LOG_ERROR("unknown transport:%s", bt_transport_text(transport).c_str());
-    return false;
-  }
-
-  LOG_ERROR("unknown device:%s", ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
-  return false;
-}
-
-bool tBTM_SEC_CB::IsLinkKeyAuthenticated(const RawAddress bd_addr,
-                                         tBT_TRANSPORT transport) {
-  tBTM_SEC_REC* sec_rec = getSecRec(bd_addr);
-  if (sec_rec) {
-    if (transport == BT_TRANSPORT_BR_EDR) {
-      return sec_rec->is_link_key_authenticated();
-    } else if (transport == BT_TRANSPORT_LE) {
-      return sec_rec->is_le_link_key_authenticated();
-    }
-    LOG_ERROR("unknown transport:%s", bt_transport_text(transport).c_str());
-    return false;
-  }
-
-  LOG_ERROR("unknown device:%s", ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
-  return false;
-}
-
-bool tBTM_SEC_CB::IsDeviceAuthenticated(const RawAddress bd_addr,
-                                        tBT_TRANSPORT transport) {
-  tBTM_SEC_REC* sec_rec = getSecRec(bd_addr);
-  if (sec_rec) {
-    if (transport == BT_TRANSPORT_BR_EDR) {
-      return sec_rec->is_device_authenticated();
-    } else if (transport == BT_TRANSPORT_LE) {
-      return sec_rec->is_le_device_authenticated();
-    }
-    LOG_ERROR("unknown transport:%s", bt_transport_text(transport).c_str());
-    return false;
-  }
-
-  LOG_ERROR("unknown device:%s", ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
-  return false;
-}
-
-bool tBTM_SEC_CB::IsLinkKeyKnown(const RawAddress bd_addr,
-                                 tBT_TRANSPORT transport) {
-  tBTM_SEC_REC* sec_rec = getSecRec(bd_addr);
-  if (sec_rec) {
-    if (transport == BT_TRANSPORT_BR_EDR) {
-      return sec_rec->is_link_key_known();
-    } else if (transport == BT_TRANSPORT_LE) {
-      return sec_rec->is_le_link_key_known();
-    }
-    LOG_ERROR("unknown transport:%s", bt_transport_text(transport).c_str());
-    return false;
-  }
-
-  LOG_ERROR("unknown device:%s", ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
-  return false;
-}
-
-bool tBTM_SEC_CB::IsDeviceBonded(const RawAddress bd_addr) {
-  tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
-  bool is_bonded = false;
-
-  if (p_dev_rec && ((p_dev_rec->sec_rec.ble_keys.key_type &&
-                     p_dev_rec->sec_rec.is_le_link_key_known()) ||
-                    p_dev_rec->sec_rec.is_link_key_known())) {
-    is_bonded = true;
-  }
-  LOG_DEBUG("Device record bonded check peer:%s is_bonded:%s",
-            ADDRESS_TO_LOGGABLE_CSTR(bd_addr), logbool(is_bonded).c_str());
-  return is_bonded;
-}
-
-#define BTM_NO_AVAIL_SEC_SERVICES ((uint16_t)0xffff)
-bool tBTM_SEC_CB::AddService(bool is_originator, const char* p_name,
-                             uint8_t service_id, uint16_t sec_level,
-                             uint16_t psm, uint32_t mx_proto_id,
-                             uint32_t mx_chan_id) {
-  tBTM_SEC_SERV_REC* p_srec;
-  uint16_t index;
-  uint16_t first_unused_record = BTM_NO_AVAIL_SEC_SERVICES;
-  bool record_allocated = false;
-
-  LOG_VERBOSE("sec_level:0x%x", sec_level);
-
-  /* See if the record can be reused (same service name, psm, mx_proto_id,
-     service_id, and mx_chan_id), or obtain the next unused record */
-
-  p_srec = &sec_serv_rec[0];
-
-  for (index = 0; index < BTM_SEC_MAX_SERVICE_RECORDS; index++, p_srec++) {
-    /* Check if there is already a record for this service */
-    if (p_srec->security_flags & BTM_SEC_IN_USE) {
-      if (p_srec->psm == psm && p_srec->mx_proto_id == mx_proto_id &&
-          service_id == p_srec->service_id && p_name &&
-          (!strncmp(p_name, (char*)p_srec->orig_service_name,
-                    /* strlcpy replaces end char with termination char*/
-                    BT_MAX_SERVICE_NAME_LEN - 1) ||
-           !strncmp(p_name, (char*)p_srec->term_service_name,
-                    /* strlcpy replaces end char with termination char*/
-                    BT_MAX_SERVICE_NAME_LEN - 1))) {
-        record_allocated = true;
-        break;
-      }
-    }
-    /* Mark the first available service record */
-    else if (!record_allocated) {
-      *p_srec = {};
-      record_allocated = true;
-      first_unused_record = index;
-    }
-  }
-
-  if (!record_allocated) {
-    LOG_WARN("Out of Service Records (%d)", BTM_SEC_MAX_SERVICE_RECORDS);
-    return (record_allocated);
-  }
-
-  /* Process the request if service record is valid */
-  /* If a duplicate service wasn't found, use the first available */
-  if (index >= BTM_SEC_MAX_SERVICE_RECORDS) {
-    index = first_unused_record;
-    p_srec = &sec_serv_rec[index];
-  }
-
-  p_srec->psm = psm;
-  p_srec->service_id = service_id;
-  p_srec->mx_proto_id = mx_proto_id;
-
-  if (is_originator) {
-    p_srec->orig_mx_chan_id = mx_chan_id;
-    strlcpy((char*)p_srec->orig_service_name, p_name,
-            BT_MAX_SERVICE_NAME_LEN + 1);
-    /* clear out the old setting, just in case it exists */
-    {
-      p_srec->security_flags &=
-          ~(BTM_SEC_OUT_ENCRYPT | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_MITM);
-    }
-
-    /* Parameter validation.  Originator should not set requirements for
-     * incoming connections */
-    sec_level &= ~(BTM_SEC_IN_ENCRYPT | BTM_SEC_IN_AUTHENTICATE |
-                   BTM_SEC_IN_MITM | BTM_SEC_IN_MIN_16_DIGIT_PIN);
-
-    if (security_mode == BTM_SEC_MODE_SP || security_mode == BTM_SEC_MODE_SC) {
-      if (sec_level & BTM_SEC_OUT_AUTHENTICATE) sec_level |= BTM_SEC_OUT_MITM;
-    }
-
-    /* Make sure the authenticate bit is set, when encrypt bit is set */
-    if (sec_level & BTM_SEC_OUT_ENCRYPT) sec_level |= BTM_SEC_OUT_AUTHENTICATE;
-
-    /* outgoing connections usually set the security level right before
-     * the connection is initiated.
-     * set it to be the outgoing service */
-    p_out_serv = p_srec;
-  } else {
-    p_srec->term_mx_chan_id = mx_chan_id;
-    strlcpy((char*)p_srec->term_service_name, p_name,
-            BT_MAX_SERVICE_NAME_LEN + 1);
-    /* clear out the old setting, just in case it exists */
-    {
-      p_srec->security_flags &=
-          ~(BTM_SEC_IN_ENCRYPT | BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_MITM |
-            BTM_SEC_IN_MIN_16_DIGIT_PIN);
-    }
-
-    /* Parameter validation.  Acceptor should not set requirements for outgoing
-     * connections */
-    sec_level &=
-        ~(BTM_SEC_OUT_ENCRYPT | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_MITM);
-
-    if (security_mode == BTM_SEC_MODE_SP || security_mode == BTM_SEC_MODE_SC) {
-      if (sec_level & BTM_SEC_IN_AUTHENTICATE) sec_level |= BTM_SEC_IN_MITM;
-    }
-
-    /* Make sure the authenticate bit is set, when encrypt bit is set */
-    if (sec_level & BTM_SEC_IN_ENCRYPT) sec_level |= BTM_SEC_IN_AUTHENTICATE;
-  }
-
-  p_srec->security_flags |= (uint16_t)(sec_level | BTM_SEC_IN_USE);
-
-  LOG_DEBUG(
-      "[%d]: id:%d, is_orig:%s psm:0x%04x proto_id:%d chan_id:%d"
-      "  : sec:0x%x service_name:[%s] (up to %d chars saved)",
-      index, service_id, logbool(is_originator).c_str(), psm, mx_proto_id,
-      mx_chan_id, p_srec->security_flags, p_name, BT_MAX_SERVICE_NAME_LEN);
-
-  return (record_allocated);
-}
-
-uint8_t tBTM_SEC_CB::RemoveServiceById(uint8_t service_id) {
-  tBTM_SEC_SERV_REC* p_srec = &sec_serv_rec[0];
-  uint8_t num_freed = 0;
-  int i;
-
-  for (i = 0; i < BTM_SEC_MAX_SERVICE_RECORDS; i++, p_srec++) {
-    /* Delete services with specified name (if in use and not SDP) */
-    if ((p_srec->security_flags & BTM_SEC_IN_USE) &&
-        (p_srec->psm != BT_PSM_SDP) &&
-        (!service_id || (service_id == p_srec->service_id))) {
-      LOG_VERBOSE("BTM_SEC_CLR[%d]: id:%d", i, service_id);
-      p_srec->security_flags = 0;
-      num_freed++;
-    }
-  }
-  return (num_freed);
-}
-
-uint8_t tBTM_SEC_CB::RemoveServiceByPsm(uint16_t psm) {
-  tBTM_SEC_SERV_REC* p_srec = &sec_serv_rec[0];
-  uint8_t num_freed = 0;
-  int i;
-
-  for (i = 0; i < BTM_SEC_MAX_SERVICE_RECORDS; i++, p_srec++) {
-    /* Delete services with specified name (if in use and not SDP) */
-    if ((p_srec->security_flags & BTM_SEC_IN_USE) && (p_srec->psm == psm)) {
-      LOG_VERBOSE("BTM_SEC_CLR[%d]: id %d ", i, p_srec->service_id);
-      p_srec->security_flags = 0;
-      num_freed++;
-    }
-  }
-  LOG_VERBOSE("psm:0x%x num_freed:%d", psm, num_freed);
-
-  return (num_freed);
-}
+}
\ No newline at end of file
diff --git a/system/stack/btm/btm_sec_cb.h b/system/stack/btm/btm_sec_cb.h
index 0a827c1dc2..403d88955b 100644
--- a/system/stack/btm/btm_sec_cb.h
+++ b/system/stack/btm/btm_sec_cb.h
@@ -38,9 +38,21 @@ class tBTM_SEC_CB {
   *****************************************************/
   tBTM_SEC_DEVCB devcb;
 
+ private:
+  friend void btm_ble_ltk_request_reply(const RawAddress& bda, bool use_stk,
+                                        const Octet16& stk);
+  friend tBTM_STATUS btm_ble_start_encrypt(const RawAddress& bda, bool use_stk,
+                                           Octet16* p_stk);
+  friend void btm_ble_ltk_request_reply(const RawAddress& bda, bool use_stk,
+                                        const Octet16& stk);
   uint16_t enc_handle{0};
+
+  friend void btm_ble_ltk_request(uint16_t handle, uint8_t rand[8],
+                                  uint16_t ediv);
   BT_OCTET8 enc_rand; /* received rand value from LTK request*/
-  uint16_t ediv{0};   /* received ediv value from LTK request */
+
+  uint16_t ediv{0}; /* received ediv value from LTK request */
+
   uint8_t key_size{0};
 
  public:
@@ -84,27 +96,6 @@ class tBTM_SEC_CB {
   void Free();
 
   tBTM_SEC_SERV_REC* find_first_serv_rec(bool is_originator, uint16_t psm);
-
-  bool IsDeviceBonded(const RawAddress bd_addr);
-  bool IsDeviceEncrypted(const RawAddress bd_addr, tBT_TRANSPORT transport);
-  bool IsDeviceAuthenticated(const RawAddress bd_addr, tBT_TRANSPORT transport);
-  bool IsLinkKeyAuthenticated(const RawAddress bd_addr,
-                              tBT_TRANSPORT transport);
-
-  bool IsLinkKeyKnown(const RawAddress bd_addr, tBT_TRANSPORT transport);
-
-  tBTM_SEC_REC* getSecRec(const RawAddress bd_addr);
-
-  bool AddService(bool is_originator, const char* p_name, uint8_t service_id,
-                  uint16_t sec_level, uint16_t psm, uint32_t mx_proto_id,
-                  uint32_t mx_chan_id);
-  uint8_t RemoveServiceById(uint8_t service_id);
-  uint8_t RemoveServiceByPsm(uint16_t psm);
-
-  void change_pairing_state(tBTM_PAIRING_STATE new_state);
-
-  // misc static methods
-  static const char* btm_pair_state_descr(tBTM_PAIRING_STATE state);
 };
 
 extern tBTM_SEC_CB btm_sec_cb;
diff --git a/system/stack/btm/security_device_record.h b/system/stack/btm/security_device_record.h
index ea25c87e19..1dd770099f 100644
--- a/system/stack/btm/security_device_record.h
+++ b/system/stack/btm/security_device_record.h
@@ -210,7 +210,12 @@ typedef enum : uint8_t {
  * Define structure for Security Device Record.
  * A record exists for each device authenticated with this device
  */
-struct tBTM_SEC_REC {
+struct tBTM_SEC_DEV_REC {
+  /**
+   * fields used for security
+   */
+  tBTM_SEC_CALLBACK* p_callback;
+  void* p_ref_data;
   tSECURITY_STATE sec_state; /* Operating state                    */
 
   tHCI_STATUS sec_status; /* Status in encryption change event  */
@@ -219,30 +224,67 @@ struct tBTM_SEC_REC {
   uint8_t pin_code_length; /* Length of the pin_code used for pairing */
   uint32_t required_security_flags_for_pairing;
   uint16_t security_required; /* Security required for connection   */
-  // security callback and its argument
-  tBTM_SEC_CALLBACK* p_callback;
-  void* p_ref_data;
 
   bool link_key_not_sent; /* link key notification has not been sent waiting for
                              name */
+  bool role_central;      /* true if current mode is central (BLE)    */
+  uint8_t sm4;            /* BTM_SM4_TRUE, if the peer supports SM4 */
   tBTM_IO_CAP rmt_io_caps;    /* IO capability of the peer device */
   tBTM_AUTH_REQ rmt_auth_req; /* the auth_req flag as in the IO caps rsp evt */
+  bool remote_supports_secure_connections;
   bool new_encryption_key_is_p256; /* Set to true when the newly generated LK
                                    ** is generated from P-256.
                                    ** Link encrypted with such LK can be used
-                                   ** for SM over BR/EDR. */
+                                   ** for SM over BR/EDR.
+                                   */
 
   // BREDR Link Key Info
   LinkKey link_key;      /* Device link key                    */
   uint8_t link_key_type; /* Type of key used in pairing        */
   uint8_t enc_key_size;  /* current link encryption key size   */
 
-  // LE Link Key Info
-  tBTM_SEC_BLE_KEYS ble_keys;
+  tBTM_SEC_BLE_KEYS ble_keys; /* LE Link Key Info */
 
   tBTM_BOND_TYPE bond_type; /* bond type */
 
+  /**
+   *  other fields for device management
+   */
+  RawAddress bd_addr; /* BD_ADDR of the device */
+  tBTM_BLE_ADDR_INFO ble;
+  tBTM_BD_NAME sec_bd_name; /* User friendly name of the device. (may be
+                               truncated to save space in dev_rec table) */
+  DEV_CLASS dev_class;      /* DEV_CLASS of the device            */
+  tBT_DEVICE_TYPE device_type;
+
+  uint32_t timestamp; /* Timestamp of the last connection   */
+  uint16_t hci_handle;     /* Handle to BR/EDR ACL connection when exists */
+  uint16_t ble_hci_handle; /* use in DUMO connection */
+
+  uint16_t suggested_tx_octets; /* Recently suggested tx octects for data length
+                                   extension */
+  uint16_t clock_offset;        /* Latest known clock offset          */
+
+  // whether the peer device can read GAP characteristics only visible in
+  // "discoverable" mode
+  bool can_read_discoverable{true};
+
+  bool remote_features_needed; /* set to true if the local device is in */
+  /* "Secure Connections Only" mode and it receives */
+  /* HCI_IO_CAPABILITY_REQUEST_EVT from the peer before */
+  /* it knows peer's support for Secure Connections */
+  bool remote_supports_hci_role_switch = false;
+  bool remote_supports_bredr;
+  bool remote_supports_ble;
+  bool remote_feature_received = false;
+
+  tBTM_LE_CONN_PRAMS conn_params;
+  tREMOTE_VERSION_INFO remote_version_info;
+
+  bool is_originator; /* true if device is originating ACL connection */
+
  public:
+  RawAddress RemoteAddress() const { return bd_addr; }
   bool is_device_authenticated() const {
     return sec_flags & BTM_SEC_AUTHENTICATED;
   }
@@ -355,13 +397,6 @@ struct tBTM_SEC_REC {
 
   uint8_t get_encryption_key_size() const { return enc_key_size; }
 
-  void increment_sign_counter(bool local);
-};
-
-class tBTM_SEC_DEV_REC {
- public:
-  RawAddress RemoteAddress() const { return bd_addr; }
-
   /* Data length extension */
   void set_suggested_tx_octect(uint16_t octets) {
     suggested_tx_octets = octets;
@@ -369,6 +404,9 @@ class tBTM_SEC_DEV_REC {
 
   uint16_t get_suggested_tx_octets() const { return suggested_tx_octets; }
   bool IsLocallyInitiated() const { return is_originator; }
+  bool SupportsSecureConnections() const {
+    return remote_supports_secure_connections;
+  }
 
   uint16_t get_br_edr_hci_handle() const { return hci_handle; }
   uint16_t get_ble_hci_handle() const { return ble_hci_handle; }
@@ -385,10 +423,6 @@ class tBTM_SEC_DEV_REC {
     return device_type & BT_DEVICE_TYPE_BLE;
   }
 
-  bool SupportsSecureConnections() const {
-    return remote_supports_secure_connections;
-  }
-
   std::string ToString() const {
     return base::StringPrintf(
         "%s %6s cod:%s remote_info:%-14s sm4:0x%02x SecureConn:%c name:\"%s\"",
@@ -398,45 +432,4 @@ class tBTM_SEC_DEV_REC {
         (remote_supports_secure_connections) ? 'T' : 'F',
         PRIVATE_NAME(sec_bd_name));
   }
-
- public:
-  RawAddress bd_addr; /* BD_ADDR of the device */
-  tBTM_BLE_ADDR_INFO ble;
-  tBTM_BD_NAME sec_bd_name; /* User friendly name of the device. (may be
-                               truncated to save space in dev_rec table) */
-  DEV_CLASS dev_class;      /* DEV_CLASS of the device            */
-  tBT_DEVICE_TYPE device_type;
-
-  uint32_t timestamp;      /* Timestamp of the last connection   */
-  uint16_t hci_handle;     /* Handle to BR/EDR ACL connection when exists */
-  uint16_t ble_hci_handle; /* use in DUMO connection */
-
-  uint16_t suggested_tx_octets; /* Recently suggested tx octects for data length
-                                   extension */
-  uint16_t clock_offset;        /* Latest known clock offset          */
-
-  // whether the peer device can read GAP characteristics only visible in
-  // "discoverable" mode
-  bool can_read_discoverable{true};
-
-  bool remote_features_needed; /* set to true if the local device is in */
-  /* "Secure Connections Only" mode and it receives */
-  /* HCI_IO_CAPABILITY_REQUEST_EVT from the peer before */
-  /* it knows peer's support for Secure Connections */
-  uint8_t sm4; /* BTM_SM4_TRUE, if the peer supports SM4 */
-  bool remote_supports_hci_role_switch = false;
-  bool remote_supports_bredr;
-  bool remote_supports_ble;
-  bool remote_supports_secure_connections;
-  bool remote_feature_received = false;
-
-  tREMOTE_VERSION_INFO remote_version_info;
-
-  bool role_central;  /* true if current mode is central (BLE)    */
-  bool is_originator; /* true if device is originating ACL connection */
-
-  // BLE connection parameters
-  tBTM_LE_CONN_PRAMS conn_params;
-  // security related properties
-  tBTM_SEC_REC sec_rec;
 };
diff --git a/system/stack/gatt/gatt_api.cc b/system/stack/gatt/gatt_api.cc
index bbe6875f62..26954f58b9 100644
--- a/system/stack/gatt/gatt_api.cc
+++ b/system/stack/gatt/gatt_api.cc
@@ -1684,12 +1684,12 @@ void gatt_load_bonded(void) {
     return;
   }
   for (tBTM_SEC_DEV_REC* p_dev_rec : btm_get_sec_dev_rec()) {
-    if (p_dev_rec->sec_rec.is_link_key_known()) {
+    if (p_dev_rec->is_link_key_known()) {
       LOG_VERBOSE("Add bonded BR/EDR transport %s",
                   ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr));
       gatt_bonded_check_add_address(p_dev_rec->bd_addr);
     }
-    if (p_dev_rec->sec_rec.is_le_link_key_known()) {
+    if (p_dev_rec->is_le_link_key_known()) {
       LOG_VERBOSE("Add bonded BLE %s",
                   ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->ble.pseudo_addr));
       gatt_bonded_check_add_address(p_dev_rec->ble.pseudo_addr);
diff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc
index b9f13c03d8..eae6ea849b 100644
--- a/system/stack/smp/smp_act.cc
+++ b/system/stack/smp/smp_act.cc
@@ -810,7 +810,7 @@ void smp_br_process_pairing_command(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
 
   LOG_VERBOSE("addr:%s", ADDRESS_TO_LOGGABLE_CSTR(p_cb->pairing_bda));
   /* rejecting BR pairing request over non-SC BR link */
-  if (!p_dev_rec->sec_rec.new_encryption_key_is_p256 &&
+  if (!p_dev_rec->new_encryption_key_is_p256 &&
       p_cb->role == HCI_ROLE_PERIPHERAL) {
     tSMP_INT_DATA smp_int_data;
     smp_int_data.status = SMP_XTRANS_DERIVE_NOT_ALLOW;
@@ -852,7 +852,7 @@ void smp_br_process_pairing_command(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
   p_cb->local_r_key = p_cb->peer_r_key;
 
   if (p_cb->role == HCI_ROLE_PERIPHERAL) {
-    p_dev_rec->sec_rec.new_encryption_key_is_p256 = false;
+    p_dev_rec->new_encryption_key_is_p256 = false;
     /* shortcut to skip Security Grant step */
     p_cb->cb_evt = SMP_BR_KEYS_REQ_EVT;
   } else {
@@ -1330,8 +1330,8 @@ void smp_key_distribution(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
     if (smp_get_state() == SMP_STATE_BOND_PENDING) {
       if (p_cb->derive_lk) {
         tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(p_cb->pairing_bda);
-        if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
-            (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_AUTHED)) {
+        if (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
+            (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_AUTHED)) {
           LOG_VERBOSE(
               "BR key is higher security than existing LE keys, don't "
               "derive LK from LTK");
diff --git a/system/stack/smp/smp_keys.cc b/system/stack/smp/smp_keys.cc
index c03e100c07..ffacca8321 100644
--- a/system/stack/smp/smp_keys.cc
+++ b/system/stack/smp/smp_keys.cc
@@ -1038,8 +1038,8 @@ bool smp_calculate_long_term_key_from_link_key(tSMP_CB* p_cb) {
   }
 
   Octet16 rev_link_key;
-  std::reverse_copy(p_dev_rec->sec_rec.link_key.begin(),
-                    p_dev_rec->sec_rec.link_key.end(), rev_link_key.begin());
+  std::reverse_copy(p_dev_rec->link_key.begin(), p_dev_rec->link_key.end(),
+                    rev_link_key.begin());
   p_cb->ltk = crypto_toolbox::link_key_to_ltk(rev_link_key,
                                               p_cb->key_derivation_h7_used);
 
diff --git a/system/stack/smp/smp_l2c.cc b/system/stack/smp/smp_l2c.cc
index 1fccd76bce..ebab7f4ec3 100644
--- a/system/stack/smp/smp_l2c.cc
+++ b/system/stack/smp/smp_l2c.cc
@@ -241,7 +241,7 @@ static void smp_br_connect_callback(uint16_t channel, const RawAddress& bd_addr,
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(p_cb->pairing_bda);
   if ((smp_get_state() == SMP_STATE_BOND_PENDING ||
        smp_get_state() == SMP_STATE_IDLE) &&
-      (p_dev_rec && p_dev_rec->sec_rec.is_link_key_known()) &&
+      (p_dev_rec && p_dev_rec->is_link_key_known()) &&
       alarm_is_scheduled(p_cb->delayed_auth_timer_ent)) {
     /* If we were to not return here, we would reset SMP control block, and
      * delayed_auth_timer_ent would never be executed. Even though we stored all
diff --git a/system/stack/test/btm/stack_btm_sec_test.cc b/system/stack/test/btm/stack_btm_sec_test.cc
index 73631887f7..3ed859bd69 100644
--- a/system/stack/test/btm/stack_btm_sec_test.cc
+++ b/system/stack/test/btm/stack_btm_sec_test.cc
@@ -130,7 +130,7 @@ TEST_F(StackBtmSecWithInitFreeTest, btm_sec_encrypt_change) {
   // Setup device
   tBTM_SEC_DEV_REC* device_record = btm_sec_allocate_dev_rec();
   ASSERT_NE(nullptr, device_record);
-  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_rec.sec_flags);
+  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_flags);
   device_record->bd_addr = bd_addr;
   device_record->hci_handle = classic_handle;
   device_record->ble_hci_handle = ble_handle;
@@ -138,23 +138,21 @@ TEST_F(StackBtmSecWithInitFreeTest, btm_sec_encrypt_change) {
   // With classic device encryption enable
   btm_sec_encrypt_change(classic_handle, HCI_SUCCESS, 0x01);
   ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED,
-            device_record->sec_rec.sec_flags);
+            device_record->sec_flags);
 
   // With classic device encryption disable
   btm_sec_encrypt_change(classic_handle, HCI_SUCCESS, 0x00);
-  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_AUTHENTICATED,
-            device_record->sec_rec.sec_flags);
-  device_record->sec_rec.sec_flags = BTM_SEC_IN_USE;
+  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_AUTHENTICATED, device_record->sec_flags);
+  device_record->sec_flags = BTM_SEC_IN_USE;
 
   // With le device encryption enable
   btm_sec_encrypt_change(ble_handle, HCI_SUCCESS, 0x01);
-  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_LE_ENCRYPTED,
-            device_record->sec_rec.sec_flags);
+  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_LE_ENCRYPTED, device_record->sec_flags);
 
   // With le device encryption disable
   btm_sec_encrypt_change(ble_handle, HCI_SUCCESS, 0x00);
-  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_rec.sec_flags);
-  device_record->sec_rec.sec_flags = BTM_SEC_IN_USE;
+  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_flags);
+  device_record->sec_flags = BTM_SEC_IN_USE;
 
   wipe_secrets_and_remove(device_record);
 }
@@ -262,7 +260,7 @@ TEST_F(StackBtmSecWithInitFreeTest, wipe_secrets_and_remove) {
   // Setup device
   tBTM_SEC_DEV_REC* device_record = btm_sec_allocate_dev_rec();
   ASSERT_NE(nullptr, device_record);
-  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_rec.sec_flags);
+  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_flags);
   device_record->bd_addr = bd_addr;
   device_record->hci_handle = classic_handle;
   device_record->ble_hci_handle = ble_handle;
diff --git a/system/stack/test/gatt/gatt_api_test.cc b/system/stack/test/gatt/gatt_api_test.cc
index 770c08f589..61faaa239f 100644
--- a/system/stack/test/gatt/gatt_api_test.cc
+++ b/system/stack/test/gatt/gatt_api_test.cc
@@ -31,18 +31,17 @@ static const size_t QUEUE_SIZE_MAX = 10;
 static tBTM_SEC_DEV_REC* make_bonded_ble_device(const RawAddress& bda,
                                                 const RawAddress& rra) {
   tBTM_SEC_DEV_REC* dev = btm_sec_allocate_dev_rec();
-  dev->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
+  dev->sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
   dev->bd_addr = bda;
   dev->ble.pseudo_addr = rra;
-  dev->sec_rec.ble_keys.key_type =
-      BTM_LE_KEY_PID | BTM_LE_KEY_PENC | BTM_LE_KEY_LENC;
+  dev->ble_keys.key_type = BTM_LE_KEY_PID | BTM_LE_KEY_PENC | BTM_LE_KEY_LENC;
   return dev;
 }
 
 static tBTM_SEC_DEV_REC* make_bonded_dual_device(const RawAddress& bda,
                                                  const RawAddress& rra) {
   tBTM_SEC_DEV_REC* dev = make_bonded_ble_device(bda, rra);
-  dev->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
+  dev->sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
   return dev;
 }
 
diff --git a/system/test/mock/mock_stack_btm_sec.cc b/system/test/mock/mock_stack_btm_sec.cc
index 7bea456324..69ffce768d 100644
--- a/system/test/mock/mock_stack_btm_sec.cc
+++ b/system/test/mock/mock_stack_btm_sec.cc
@@ -46,6 +46,7 @@ struct BTM_CanReadDiscoverableCharacteristics
 struct BTM_ConfirmReqReply BTM_ConfirmReqReply;
 struct BTM_GetClockOffset BTM_GetClockOffset;
 struct BTM_GetPeerDeviceTypeFromFeatures BTM_GetPeerDeviceTypeFromFeatures;
+struct BTM_GetSecurityFlagsByTransport BTM_GetSecurityFlagsByTransport;
 struct BTM_IsAuthenticated BTM_IsAuthenticated;
 struct BTM_IsEncrypted BTM_IsEncrypted;
 struct BTM_IsLinkKeyAuthed BTM_IsLinkKeyAuthed;
@@ -121,6 +122,7 @@ bool BTM_BothEndsSupportSecureConnections::return_value = false;
 bool BTM_CanReadDiscoverableCharacteristics::return_value = false;
 uint16_t BTM_GetClockOffset::return_value = 0;
 tBT_DEVICE_TYPE BTM_GetPeerDeviceTypeFromFeatures::return_value = 0;
+bool BTM_GetSecurityFlagsByTransport::return_value = false;
 bool BTM_IsAuthenticated::return_value = false;
 bool BTM_IsEncrypted::return_value = false;
 bool BTM_IsLinkKeyAuthed::return_value = false;
@@ -174,6 +176,13 @@ tBT_DEVICE_TYPE BTM_GetPeerDeviceTypeFromFeatures(const RawAddress& bd_addr) {
   inc_func_call_count(__func__);
   return test::mock::stack_btm_sec::BTM_GetPeerDeviceTypeFromFeatures(bd_addr);
 }
+bool BTM_GetSecurityFlagsByTransport(const RawAddress& bd_addr,
+                                     uint8_t* p_sec_flags,
+                                     tBT_TRANSPORT transport) {
+  inc_func_call_count(__func__);
+  return test::mock::stack_btm_sec::BTM_GetSecurityFlagsByTransport(
+      bd_addr, p_sec_flags, transport);
+}
 bool BTM_IsAuthenticated(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
   inc_func_call_count(__func__);
   return test::mock::stack_btm_sec::BTM_IsAuthenticated(bd_addr, transport);
diff --git a/system/test/mock/mock_stack_btm_sec.h b/system/test/mock/mock_stack_btm_sec.h
index 824c7b2047..f070cde0d6 100644
--- a/system/test/mock/mock_stack_btm_sec.h
+++ b/system/test/mock/mock_stack_btm_sec.h
@@ -109,6 +109,22 @@ struct BTM_GetPeerDeviceTypeFromFeatures {
 extern struct BTM_GetPeerDeviceTypeFromFeatures
     BTM_GetPeerDeviceTypeFromFeatures;
 
+// Name: BTM_GetSecurityFlagsByTransport
+// Params: const RawAddress& bd_addr, uint8_t* p_sec_flags, tBT_TRANSPORT
+// transport Return: bool
+struct BTM_GetSecurityFlagsByTransport {
+  static bool return_value;
+  std::function<bool(const RawAddress& bd_addr, uint8_t* p_sec_flags,
+                     tBT_TRANSPORT transport)>
+      body{[](const RawAddress& /* bd_addr */, uint8_t* /* p_sec_flags */,
+              tBT_TRANSPORT /* transport */) { return return_value; }};
+  bool operator()(const RawAddress& bd_addr, uint8_t* p_sec_flags,
+                  tBT_TRANSPORT transport) {
+    return body(bd_addr, p_sec_flags, transport);
+  };
+};
+extern struct BTM_GetSecurityFlagsByTransport BTM_GetSecurityFlagsByTransport;
+
 // Name: BTM_IsAuthenticated
 // Params: const RawAddress& bd_addr, tBT_TRANSPORT transport
 // Return: bool
-- 
2.34.1

